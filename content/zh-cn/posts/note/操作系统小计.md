---
title: "操作系统小记"
date: "2019-02-21"
description: "简易服务器"
featured : false
categories: ["notes"]
tags: [ "notes" ]
series: [ "notes" ]
images: []
---

操作系统小记

<!--more-->

### 并发系统

为什么需要并行

- 业务需求，不同的线程完成不同的功能，交给操作系统进行调度
- 性能，提高cpu密集型在多核处理机的效率

### 同步synchronous和异步asynchronous

同步等待调用返回

异步调用马上返回，但是后台新开一个线程/进行慢慢运行，再返回

### 并发Concurrency和并行Parallelism

多核CPU天然并行，不同的CPU做不同的事

并发，是指通过调度，一会儿做这个事，一会儿做另一个事

### 临界区

- 表示一个公共的资源或者共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界资源被占用，其他线程想使用这个资源，必须等待
- 进程 ==》 进入去(申请资源，如果资源被占用，就进去阻塞等待队列) ==》临界区 ==》退出区

### 阻塞Blocking和非阻塞N-Blocking

- 阻塞和非阻塞通常用来形容多线程之间的相互影响
- 阻塞：一个线程占用了临界区资源，那么其他所有需要这个资源的线程都必须再这个临界区中等待，等待导致线程挂起，这就是阻塞。如果占用资源的线程一直不释放资源，那么其他所有在这个临界区上的的线程都不能工作
- 非阻塞允许多个线程同时进入临界区

### 死锁Deadlock，饥饿Starvation，活锁Livelock

死锁：

一组进程中的每一个进程都在等待仅由该组中的其他进程才能引发的事件，那么该组进程是死锁的

饥饿：

由于个别资源长期被其他进程占用，而致等待该资源的进程迟迟无法开始运行

活锁：

进程为了避免死锁，而释放资源，导致资源一直在被释放和抢占中，同时活锁的进程也无法执行

### 并发级别

#### 阻塞

- 当一个线程进入临界区后，其他线程必须等待

#### 无障碍

- 无障碍是一种最弱的非阻塞调度
- 自由出入临界区
- 无竞争时，有限步内完成操作
- 有竞争时，回滚数据
- 各个线程在尝试获取一个独立的系统快照

#### 无锁

- 首先无障碍的
- 保证在至少一个线程可以胜出竞争

```java
while(!atomicVar.compareAndSet(localVar,localVar+1)){//无锁计算
    localVar = atomicVar.get();
}
```



#### 无等待

- 首先无锁的
- 要求所有的线程都必须在有限步内完成
- 一定无饥饿

### Amdahl定律

- 串行系统并行化后的加速比的计算公式和理论上限

- 加速比 = 优化前系统耗时/优化后系统耗时

  CPU并行化后系统耗时的计算公式：
$$
Tn = T_1(F+\frac{1}{n}(1-F)) = \frac{1}{F+\frac{1}{n}(1-F)}
$$ {n:处理器个数，F串行比例，(1-F)并行比例}



