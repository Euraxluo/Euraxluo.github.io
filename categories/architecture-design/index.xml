<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>architecture design on Euraxluo Blog</title><link>/categories/architecture-design/</link><description>Recent content in architecture design on Euraxluo Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright><lastBuildDate>Mon, 03 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="/categories/architecture-design/index.xml" rel="self" type="application/rss+xml"/><item><title>软件架构1-Tier</title><link>/posts/architecture_design/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%841-tier/</link><pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/architecture_design/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%841-tier/</guid><description>软件架构 软件开发过程的概述 在行业中，架构师、开发人员和产品所有者花费大量时间研究和讨论业务需求。在软件工程术语中，这被称为需求收集和分析。
一旦我们完成了业务需求，我们坐下来讨论我们必须实现的用例。这包括尽早找出角落的情况&amp;amp;将乐高积木组装在一起。
如果您是文档的爱好者，您可能还想编写高级设计文档。现在，我们已经了解了业务需求、用例、拐角用例等等。现在开始研究如何选择合适的技术堆栈来实现用例。
####　概念证明 POC
POC帮助我们对技术和基本用例实现有一个更近、更实际的了解。我们将深入了解技术、性能或其他技术限制的利弊。
如果我们使用的是全新的技术，那么学习曲线就会有所帮助，产品所有者、利益相关者等非技术人员也会有一些具体的东西可以使用，并以此为基础做出进一步的决定。
现在，这只是一个工业规模的产品。如果你是一个独立开发者或一个小团队，你可以跳过POC部分，从主代码开始。
所以，我们向利益相关者展示POC，如果每个人都满意，我们最终在GitHub上创建主回购和我们的第一个开发分支，或任何其他类似的业务喜欢的代码托管服务。
所以，到现在为止，你应该已经意识到在第一时间获得正确的架构和web架构知识对开发人员是多么的重要。
Tier 我将从讨论软件架构中涉及的不同层次开始课程。这就像是对软件架构领域的鸟瞰，很重要的一点是要很好地理解。
什么是一层？ 可以将层看作应用程序或服务中组件的逻辑分离。当我说分离时，我指的是组件级的物理分离，而不是代码级。
组件的意思是什么？ 数据库
后端应用服务器
用户界面
消息传递
缓存
Single Tier Applications 单层应用程序是指用户界面、后端业务逻辑和数据库都驻留在同一台机器中的应用程序。
单层应用程序的典型例子是桌面应用程序，如moffice、PC游戏或图像编辑软件，如Gimp。
单层应用的优点 单层应用程序的主要优点是它们没有网络延迟，因为每个组件都位于同一台机器上。这就提高了软件的性能。
没有数据请求到后端服务器不时，这将使用户体验缓慢。在单层应用中，由于数据位于同一台机器上，所以数据是很容易和快速获得的。
尽管这在很大程度上取决于机器的功能有多强大&amp;amp;软件的硬件要求，但要衡量单层应用程序的真正性能
此外，用户的数据保存在他的机器&amp;amp;不需要通过网络传输。这在最大程度上保证了数据安全。
单层应用的缺点 单层应用程序的一个大缺点是业务无法控制应用程序。一旦软件交付，除非客户通过连接到远程服务器或下载并安装补丁手动更新软件，否则不可能对代码或功能进行更改。
因此，在90年代，如果一款游戏带有漏洞代码，那么工作室便无能为力。由于软件的缺陷，他们最终不得不面对相当大的压力。产品的测试必须彻底，不能有任何差错。
单层应用程序中的代码也很容易被修改和反向工程。对企业来说，安全性是最低限度的。
此外，应用程序的性能和外观可能会不一致，因为它在很大程度上取决于用户机器的配置。
Two Tier Applications 两层应用程序包括客户机和服务器。客户端将在一台机器中包含用户界面和业务逻辑。后端服务器将是运行在不同机器上的数据库。数据库服务器由企业托管并对其进行控制。
为什么需要两层应用程序?为什么不将业务逻辑驻留在另一台机器上并对其进行控制呢?
优点:
应用程序代码也不容易被第三方访问
在某些情况下，两层应用程序会派上用场，例如，待办事项列表应用程序或类似的计划表或生产力应用程序。在这些场景中，即使代码被第三方访问，也不会对业务造成重大损害。相反，好处是由于代码和用户界面驻留在同一台机器上，因此对后端服务器的网络调用更少，从而降低了应用程序的延迟。只有当用户创建完待办事项列表并希望持久化更改时，应用程序才会调用数据库服务器。
另一个例子便是基于浏览器和应用的在线游戏。游戏文件非常重，当用户第一次使用应用时，他们只需要在客户端下载一次。此外，它们进行网络调用只是为了保持游戏状态持久。
经济，更少的服务器调用意味着在服务器上花费更少的钱，这自然是经济的。
不过，这在很大程度上取决于我们的业务需求和用例，如果我们想在编写服务时选择这种类型的层。我们可以将用户界面和业务逻辑保留在客户机上，也可以将业务逻辑移动到专用的后端服务器上，这将使其成为一个三层应用程序。这是我接下来要讨论的
Tree Tier Applications 三层应用程序非常流行，并在行业中广泛使用。几乎所有的简单网站，如博客，新闻网站等都属于这一类。
在一个三层的应用程序中，用户界面、应用程序逻辑和数据库都位于不同的机器上，因此有不同的层。他们是分开的。
因此，如果我们以一个简单的博客为例，用户界面将使用Html, JavaScript, CSS编写，后端应用程序逻辑将运行在服务器上，如Apache &amp;amp;数据库将是MySQL。三层架构最适合简单的用例。
N Tier Applications n层应用程序是指包含三个以上组件的应用程序。
这些组成部分是什么?
缓存 异步行为的消息队列 负载均衡器 用于搜索大量数据的服务器 处理大量数据的组件 运行异构技术(通常称为web服务)的组件等。 所有像Instagram, Facebook这样的社交应用，像Uber, Airbnb这样的大型行业服务，像Pokemon Go这样的在线大型多人游戏，具有奇特功能的应用都是n层应用。</description></item><item><title>软件架构2</title><link>/posts/architecture_design/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%842/</link><pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate><guid>/posts/architecture_design/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%842/</guid><description>软件架构 什么是Web架构 Web架构包括数据库、消息队列、缓存、用户界面等多个组件，它们相互结合，形成在线服务
这是web应用程序的典型架构，在大多数在线运行的应用程序中使用。
如果我们对图中所涉及的组件有一个了解，那么我们总是可以在这个体系结构的基础上构建更复杂的需求。
Client Server Architecture客户服务器结构 在讨论两层、三层和n层架构时，我们已经对客户端-服务器架构有了一些了解。现在我们来详细看看。
客户端-服务器架构是web的基本构件。
该体系结构在请求-响应模型上工作。客户端向服务器发送请求以获取信息&amp;amp;服务器响应它。
你浏览的每个网站，无论是Wordpress博客还是Facebook、Twitter或银行应用程序，都是建立在客户-服务器架构上的。
只有非常小的比例的业务网站和应用程序使用peer to peer体系结构，这与客户机-服务器不同。
client 客户端保存我们的用户界面。用户界面是应用程序的表示部分。它是用Html, JavaScript, CSS编写的，并负责应用程序的外观和感觉。
用户界面在客户机上运行。客户端可以是移动应用程序、台式机或像iPad这样的平板电脑。它也可以是基于web的控制台，运行命令与后端服务器交互。
简单地说，客户端就是我们应用程序的窗口。在业界，编写基于web的用户界面的开源技术有ReactJS、AngularJS、VueJS、Jquery等。所有这些库都使用JavaScript。
编写前端也有很多其他的技术，我只是列出了目前最流行的几种。
不同的平台需要不同的框架和库来编写前端。例如，运行Android的手机将需要一套不同的工具，运行苹果或Windows操作系统的手机将需要一套不同的工具
Types of Client Thin Client 瘦客户机是仅持有应用程序用户界面的客户机。它没有任何形式的商业逻辑。对于每个操作，客户端都向后端服务器发送一个请求。就像在三层应用程序中一样。 Thick Client( Fat client) 胖客户机持有全部或部分业务逻辑。这些是两层应用程序。我们已经讲过了，如果你还记得的话。胖客户端的典型例子是实用程序、在线游戏等
Server web服务器的主要任务是接收来自客户端的请求，并根据从客户端收到的请求参数执行业务逻辑后提供响应。
每一个在线运行的服务都需要一个服务器来运行。运行web应用程序的服务器通常被称为应用服务器。
除了应用程序服务器之外，还有其他类型的服务器，它们被分配特定的任务，例如
代理服务器
邮件服务器
文件服务器
虚拟服务器
服务器配置和类型可以根据用例的不同而不同。
例如，如果我们运行用Java编写的后端应用程序代码，我们会选择Apache Tomcat或Jetty
对于简单的用例，比如托管网站，我们会选择Apache HTTP服务器。
一个web应用程序的所有组件都需要一个服务器来运行。可以是数据库、消息队列、缓存或任何其他组件。在现代应用程序开发中，甚至用户界面也单独驻留在专用服务器上
Server-Side Rendering SSR 后端渲染技术，开发人员使用服务器在后台呈现用户界面，然后将呈现的数据发送给客户端。这种技术被称为服务器端渲染。我将在后面的课程中讨论客户端和服务器端渲染的优缺点。
客户端渲染Vs服务器端渲染(Client-Side Vs Server-Side Rendering) 当用户从服务器请求一个网页&amp;amp;浏览器收到响应。它必须以HTML页面的形式在窗口上呈现响应
为此，浏览器有几个组件，例如:
浏览器引擎 渲染引擎 JavaScript解释器 网络和UI后端 数据存储等 渲染引擎构建DOM树，渲染并绘制结构。
Server-Side Rendering
为了避免客户端的渲染时间，开发人员经常在服务器端渲染UI，在那里生成HTML，然后直接将HTML页面发送给UI。这种技术称为服务器端呈现。它确保更快的UI渲染，避免UI加载时间在浏览器窗口，因为页面已经创建&amp;amp;浏览器不需要做很多组装和渲染工作。
服务器端呈现方法非常适合交付静态内容，比如WordPress博客。这也有利于搜索引擎优化，因为爬虫可以很容易地阅读生成的内容。
然而，现代网站高度依赖于Ajax。在这样的网站中，特定模块或页面部分的内容必须在运行中获取和呈现
因此，服务器端呈现并没有多大帮助。对于每一个ajax请求，该方法不只是向客户机发送所需的内容，而是在服务器上生成整个页面。这个过程会消耗不必要的带宽，也不能提供流畅的用户体验</description></item><item><title>MVC分层模型</title><link>/posts/architecture_design/mvc/</link><pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate><guid>/posts/architecture_design/mvc/</guid><description>MVC分层模型 DAO 模式初识 PO(persistant object) 持久对象 在o/r映射的时候出现的概念，如果没有o/r映射，没有这个概念存在了。通常对应数据模型(数据库),本身还有部分业务逻辑的处理。可以看成是与数据库中的表相映射的java对象。最简单的PO就是对应数据库中某个表中的一条记录，多个记录可以用PO的集合。PO中应该不包含任何对数据库的操作。
最形象的理解就是一个PO就是数据库中的一条记录。
好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。
VO(value object) 值对象 通常用于业务层之间的数据传递，和PO一样也是仅仅包含数据而已。但应是抽象出的业务对象,可以和表对应,也可以不,这根据业务的需要.个人觉得同TO(数据传输对象),在web上传递。
主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值。
TO(Transfer Object)，数据传输对象 在应用程序不同tie(关系)之间传输的对象
BO(business object) 业务对象 从业务模型的角度看,见UML元件领域模型中的领域对象。封装业务逻辑的java对象,通过调用DAO方法,结合PO,VO进行业务操作。
POJO(plain ordinary java object) 简单无规则java对象 纯的传统意义的java对象。就是说在一些Object/Relation Mapping工具中，能够做到维护数据库表记录的persisent object完全是一个符合Java Bean规范的纯Java对象，没有增加别的属性和方法。我的理解就是最基本的Java Bean，只有属性字段及setter和getter方法！。
DTO（Data Transfer Object）：数据传输对象 这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。
DAO(data access object) 数据访问对象 是一个sun的一个标准j2ee设计模式，这个模式中有个接口就是DAO，它负持久层的操作。为业务层提供接口。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法,结合PO对数据库进行相关的操作。夹在业务逻辑与数据库资源中间。配合VO, 提供数据库的CRUD操作&amp;hellip;
这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.
主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO
O/R Mapper 对象/关系 映射 定义好所有的mapping之后，这个O/R Mapper可以帮我们做很多的工作。通过这些mappings,这个O/R Mapper可以生成所有的关于对象保存，删除，读取的SQL语句，我们不再需要写那么多行的DAL代码了。
实体Model(实体模式)
DAL(数据访问层)
IDAL(接口层)
DALFactory(类工厂)
BLL(业务逻辑层)
BOF Business Object Framework 业务对象框架
SOA Service Orient Architecture 面向服务的设计
EMF Eclipse Model Framework Eclipse建模框架</description></item></channel></rss>