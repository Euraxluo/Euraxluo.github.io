<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>redis on Euraxluo Blog</title><link>/categories/redis/</link><description>Recent content in redis on Euraxluo Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright><lastBuildDate>Sun, 13 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="/categories/redis/index.xml" rel="self" type="application/rss+xml"/><item><title>Redis 实现分布式锁</title><link>/posts/redis/redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link><pubDate>Sun, 13 Feb 2022 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid><description>import redis import time import math import threading import typing from redis import Redis class _WatchThread(threading.Thread): def __init__(self, target, args=(), kwargs={}): super(_WatchThread, self).__init__() self.func = target self.args = args self.kwargs = kwargs self.result = None def run(self): # 接受返回值 self.result = self.func(*self.args, **self.kwargs) def get_result(self, default=None, transform=lambda x: x): # 线程不结束,返回值为None try: return transform(self.result) except Exception as e: return transform(default) # 加载脚本并执行的函数 def _script_load(script): sha = [None] def call(conn: Redis, keys=None, args=None, force_eval=False): if args is None: args = [] if keys is None: keys = [] if not force_eval: # 加载并缓存校验和 if not sha[0]: sha[0] = conn.</description></item><item><title>Redis API及数据结构</title><link>/posts/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid><description>&lt;p>本文介绍了redisApi以及数据结构&lt;/p></description></item><item><title>Redis Cluster</title><link>/posts/redis/rediscluster-1/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/rediscluster-1/</guid><description>Redis Cluster 背景 并发量 &amp;lt;10万dps
数据量 单机内存&amp;lt;256G
带宽 网卡限制
解决方式 提高机器配置
分布式
数据分布 | 分布方式 | 特点 | 典型产品 |
| &amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;ndash; |
| 哈希分布 | 数据分散度高数据分布业务无关无法顺序访问支持批量操作 | 一致性哈希MemcacheRedis Cluster缓存产品 |
| 顺序分布 | 数据分散度易倾斜键值业务相关可顺序访问支持批量操作 | BigTableHBase |
哈希分布 节点取余：hash(key)%nodes 客户端分片：哈希+取余
节点扩容：扩容时需要数据迁移
翻倍扩容：扩容时最好多倍扩容
一致性哈希 有一个token环，节点在token环上，会为每个key分配一个token，在依据token在环上顺时针寻找最近的节点
客户端分片：哈希+顺时针选择节点
节点伸缩：扩容时减少影响的范围
翻倍伸缩：保证最小迁移数据和保证负载均衡
虚拟槽分区 预设虚拟槽：每个槽映射一个数据子集，一般比节点数大
良好的哈希函数：CRC16
服务端管理节点，槽，数据：例如Redis Cluster
搭建集群 Redis Cluster架构 节点，很多节点，都负责读写
meet，使用raft协议，是互相通信的基础
指派槽，把节点指派槽，才能正常读写
复制，保证高可用
安装 配置安装 节点配置 port ${port} daemonize yes dir &amp;#34;path/to/run&amp;#34; dbdilename &amp;#34;dump-${port}.</description></item><item><title>Redis Cluster 2</title><link>/posts/redis/rediscluster-2/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/rediscluster-2/</guid><description>集群伸缩 伸缩原理 伸：增加节点 缩：节点下线
集群伸缩：槽和数据在节点之间的移动
扩容集群 准备新节点 打开集群模式
配置和其他节点统一
启动后是孤立的节点
加入集群meet 在集群节点中配置：cluster meet 127.1 &amp;lt;newnodeport&amp;gt;
使用redis-trib.rb：
redis-trib.rb ad-node new_host:new_port existing_host:existing_port --slave --master_id &amp;lt;arg&amp;gt;{扩展参数是配置为从节点}
为它迁移槽和数据可以实现扩容
可以作为从节点负责故障转移
迁移槽和数据 1). 对目标节点发送cluster setslot &amp;lt;slot&amp;gt; importing &amp;lt;sourceNodeId&amp;gt;,让目标节点准备导入槽的数据
2). 对源节点发送cluster setslot &amp;lt;slot&amp;gt; migrating &amp;lt;targetNodeId&amp;gt;,让源节点准备迁出槽
3). 源节点循环执行cluster getkeysinslot &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;,每次获取count个属于槽的键
4). 在源节点上执行migrate &amp;lt;targetIp&amp;gt; &amp;lt;targetPort&amp;gt; key 0{对应数据库，master只有db0} &amp;lt;timeout&amp;gt;,死循环，知道所有的key迁移完成
5). 重复执行3)~4)知道槽下所有的key迁移到目标节点
6). 向集群中的所有主节点发送cluster setslot &amp;lt;slot&amp;gt; node &amp;lt;targetNode Id&amp;gt;,通知槽已经重新分配给目标节点
伪代码：
def move_slot(source,target,slot): #目标节点准备导入槽 target.cluster(&amp;#34;setslot&amp;#34;,slot,&amp;#34;importing&amp;#34;,source,nodeID); #源节点准备导出槽 source.cluster(&amp;#34;setslot&amp;#34;,slot,&amp;#34;migrating&amp;#34;,target,nodeId); while true: #批量从源节点获取key keys = source.</description></item><item><title>Redis Cluster 3</title><link>/posts/redis/rediscluster-3/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/rediscluster-3/</guid><description>RedisCluster 客户端使用 moved重定向 对任意节点发送键命令
节点会计算槽和对应节点确定这个键是否指向自身
如果指向自身，就执行命令，返回key所在的槽
否则就回复moved异常，客户端拿到这个moved后，重定向节点，重新发送命令
ASK重定向 解决槽迁移时客户端的查询问题
对源节点发送键命令
节点发现正在进行槽迁移，回复客户端ask转向
客户端对目标节点Asking，发送命令
目标节点返回响应结果
两者的区别 两者都是客户端重定向
moved：槽已经确定迁移
ask：槽还在迁移中
smart客户端 目标：追求性能（不能使用代理模式）
从集群中选取一个可运行节点，使用cluster slots 初始化槽和节点映射
将cluster slots的结果映射到本地，为每个节点都创建一个连接池
准备执行命令
执行命令 通过key哈希模16383，得到slot，通过本地映射得到节点，再通过连接池去连接
如果连接出错，可能槽迁移，也可能是连接异常，如果槽迁移，那么
我们随机访问一个活跃节点，节点会返回moved异常
我们得到槽迁移的结果，更新我们的slot和nodes的映射（确定槽迁移）
然后再去连接目标节点
如果命令发送多次未成功，显示异常Too many cluster redirection
jiedisCluster使用 Set&amp;lt;HostAndPort&amp;gt; nodeList = new HashSet&amp;lt;HostAndPort&amp;gt;(); nodeList.add(new HostAndPort(HOST1,PORT1)); nodeList.add(new HostAndPort(HOST2,PORT2)); nodeList.add(new HostAndPort(HOST3,PORT3)); nodeList.add(new HostAndPort(HOST4,PORT4)); nodeList.add(new HostAndPort(HOST5,PORT5)); nodeList.add(new HostAndPort(HOST6,PORT6)); JedisCluster redisCluster = new JedisCluster(nodeList,timeout,poolConfig); TIPS 单例：内置了所有节点的连接池，并可以用来做故障转移
无需手动借还连接池
合理设置commons-pool
整合spring //工厂 import redis.client.jedis.JedisCluster; public class JedisClusterFactory{ private JedisCluster jedisCluster; private List&amp;lt;String&amp;gt; hostPoetList; private int timeout; private Logger logger = LoggerFactory.</description></item><item><title>Redis Sentinel</title><link>/posts/redis/redissentinel/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redissentinel/</guid><description>Redis Sentinel 主从复制的问题 手动故障转移
写能力和存储能力受限
Redis Sentinel架构 有多个Sentinel节点
不用来存储数据
多个节点判断master节点的故障，进行故障转移
保证高可用，即便一个Sentinel节点挂点也没事
客户端只会记录sentinel的地址（因为sentinel会进行故障转移，master节点地址不固定）
一套sentinel可以监控多套master-slave，利用master-name作为标识
Sentinel的故障转移 多个sentinel发现并确认master有问题
选举出一个sentinel作为领导
选出一个slave作为新的master
通知其余slave成为新的master的slave
通知客户端主从变化
等待老的master复活成为新的master的slave
安装与配置 主从配置：
sed &amp;quot;s/6380/6381/g&amp;quot; redis-6380.conf &amp;gt; redis-6381.conf
查看：
cat redis-6381.conf|grep -v &amp;quot;#&amp;quot; |grep -v &amp;quot;^$&amp;quot;
Sentinel配置
port ${port} dir &amp;#34;&amp;#34; logfile &amp;#34;${port}.log&amp;#34; sentinel monitor mastername 127.1 port{主节点端口} 2{故障发现个数} #判断失败时间 30000毫秒 sentinel down-after-milliseconds mastername 30000 #并发度 sentinel parallel-syncs mastername 1 sentinel failover-timeout mastername 180000 客户端与sentinel连接 高可用 服务端高可用
客户端高可用
实现原理 获取全部的sentinel节点
我需要给sentinel我想连接的mastername</description></item><item><title>Redis基础学习</title><link>/posts/redis/redis%E5%9F%BA%E7%A1%80/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E5%9F%BA%E7%A1%80/</guid><description>Redis基础学习 Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。
安装和基本命令 安装： Ubuntu18.04：sudo apt-get install redis-server
安装redis后会自动安装redis-cli
也可以安装图形工具
sudo snap install redis-desktop-manager
基本操作 检查Redis服务器系统进程 ps -aux |grep redis
通过启动命令检查Redis服务器状态 netstat -nlt|grep 6379
访问Redis 最简启动
redis-server
指定配置文件启动
redis-server config/redis-6380.conf
验证
ps -ef|grep redis
netstat -antpl | grep redis
redis-cli -h ip -p port ping
访问
redis-cli -a euraxluo -h 127.1 -p 6379
基本命令 0.keys* 时间复杂度是On
keys xx?
keys xx*
keys xx[x-x]*
1.判断一个key是否存在 O1 exists key</description></item><item><title>Redis的主从复制</title><link>/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid><description>Redis的主从复制 单机部署的问题 机器故障（高可用）
容量瓶颈（分布式）
QPS瓶颈（分布式）
主从复制的作用 为一个数据提供了副本
slave从master复制一个备份库
master可以有多个slave
一个slave只能有一个master
数据流向是单向的，由master&amp;ndash;&amp;gt;slave
扩展读性能，可以实现读写分离
主从复制实现 slaveof slaveof 127.1 6380
取消复制
slaveof no one
配置 #配置这个redis服务复制ip:port这个redis作为他的slave slaveof ip port #只读,必须保证从和主的内容一致 slave-read-only yes 两种方式的比较 | 方式 | 命令 | 配置 |
| &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;ndash; |
| 优点 | 无需重启 | 统一配置 |
| 缺点 | 不便于管理 | 需要重启 |
使用配置的方式实现主从复制，需要重启原来的redis服务器 config redis-cli -h 127.1 -p 6379 shutdown
config ps -ef |grep redis-server</description></item><item><title>Redis的持久化</title><link>/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</guid><description>Redis的持久化 Redis持久化作用 什么是持久化 redis的所有数据保存在内存中，对数据的更新回异步的保存在磁盘中
持久化方式 快照 MySQL Dump
Redis RDB
日志 MySQL Binlog
Hbase HLog
Redis AOF
RDB持久化 什么是RDB redis可以通过命令，把当前数据库的状态保为一个RDB文件（二进制）
也可以通过命令把硬盘上的RDB载入到redis中
同时RDB文件也是一个复制的媒介
触发机制 save 通过save命令让redis生成rdb文件，生成成功返回‘OK’
同步命令，阻塞命令，会导致服务器阻塞
会替换老的rdb文件
复杂度On
bgsave 接收到bgsave后，redis利用linux的fork()命令产生一个子进程，让产生的子进程去生成RDB文件，返回‘Backgroud saving started’
fork()函数也是一阻塞命令，一般情况下很快
会替换老的rdb文件
复杂度On
save与bgsave比较 | 命令 | save | bgsave |
| &amp;mdash;- | &amp;mdash;- | &amp;mdash;- |
| io类型 |同步 | 异步 |
| 是否阻塞 | 是 | 是 |
| 时间复杂度 | On | On |</description></item><item><title>Redis高级特性初识别</title><link>/posts/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid><description>Redis高级特性初识 慢查询 客户端请求的生命周期 客户端发送命令
入队列
执行命令（慢查询在这一阶段）
返回客户端
（客户端超时，不一定是慢查询，慢查询只是客户端超时的一个可能）
配置 slowlog-max-len，固定长度
slowlog-log-slower-than，慢查询阈值（单位微秒）
=0，记录所有命令
&amp;lt;0，不记录任何命令
#1. 第一次开启配置 config get slowlog-max-len = 128 config get slowlog-log-slower-than = 10000 #2. 修改默认配置重启 #3. 动态配置 config set slowlog-max-len = 128 config set slowlog-log-slower-than = 10000 API 慢查询会把命令放在内存中
slowlog get [n]：获取慢查询队列
slowlog len ：获取慢查询队列长度
slowlog reset：清空慢查询队列
定期持久化查询
TIPS slowlog-max-len 不要设置的过大，默认为10ms，通常设置为1ms
slowlog-log-slower-than 不要设置过小，通常设置为1000左右
理解命令生命周期
pipeline 流水线 n次通信时间=n次命令时间+n次网络时间
使用pipeline：1次网络+n次命令
客户端实现 maven:
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;redis.clients&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jedis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.9.0&amp;lt;/version&amp;gt; &amp;lt;type&amp;gt;jar&amp;lt;/type&amp;gt; &amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; 没有使用pipeline</description></item><item><title>Redis基础配置</title><link>/posts/redis/redis%E9%85%8D%E7%BD%AE/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>/posts/redis/redis%E9%85%8D%E7%BD%AE/</guid><description>Redis的特点 速度快 使用内存
使用C语言
单线程
持久化 对数据的更新，异步保存到磁盘上 多种数据结构 strings/Blobs/Bitmaps
Hash Tables
Linked Lists
Sets
Sorted Sets
BitMaps
HyperLogLog(超小内存唯一值计数)
GEO
多语言支持 功能丰富 发布topic
支持lua脚本
支持简单的事务
支持pipeline
高可用，分布式 Redis初识 缓存
计数器
消息队列系统
排行榜
实时系统
社交队列
Redis 可执行文件介绍 redis-server：redis服务器
redis-cli：rdis命令行服务端
redis-benchmark：性能测试
redis-check-aof： aof修复工具
redis-check-dump：rdb文件检查工具
redis-sentinel：sentinel服务器
启动方式 最简启动 启动
redis-server
验证
ps -ef|grep redis
netstat -antpl | grep redis
redis-cli -h ip -p port ping
配置启动 daemonsize:是否以守护进程的方式启动
port:redis对外端口号
logfile:redis系统日志
dir:redis工作目录
#redis是单进程，但是一般电脑是多线程的，所以我们可以开多个redis进程，通过不同的端口来访问 mkdir -p /home/redis/config cp /etc/redis/redis.</description></item></channel></rss>