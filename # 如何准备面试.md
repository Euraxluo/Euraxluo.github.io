# 如何准备算法面试 

## 从排序问题开始

- 有没有可能存在大量重复的元素
- 是否大部分数据距离它正确的位置很近
- 是否近乎有序
- 是否数据的取值范围很有限
- 是否需要稳定排序
- 是否使用链表存储
- 数据的大小是否可以装载在内存中

## 技术面的可能的问题
- 项目经历，项目中遇到的问题
- 遇到过那些bug，怎么解决
- 面向对象
- 设计模式
- 网络相关
- 设计模式
- 系统设计

## 关于思考行为方式的相关问题
- 遇到过的最大的挑战
- 翻过的错误
- 遭遇的失败
- 最享受的工作内容
- 遇到冲突的处理方式
- 做的最与众不同的事

## 关于合适的问题
- 小组的运行模式
- 项目的后续规划
- 产品中可能遇到的问题
- 为什么会选择某些技术，标准
- 我对某项技术很感兴趣，在入职的小组中有怎样的机会深入这种技术

## 算法面试中不会涉及高级数据结构和算法
- 红黑树
- B-Tree
- 斐波那契堆
- FFT
- 数论
- 计算几何
- 从暴力解法开始，逐步优化

## 时间复杂度

### 常见的时间复杂度

二分：Ologn

查找数组中的最值On

归并排序：Onlogn，最差为n^2

选择排序：On^2

插入排序：On^2,最好为On

快速排序：Onlogn



### 一个面试问题

有一个字符串数组，将字符串数组中的每一个字符串按照字母序排序之后，再将整个字符串按照字典序排序，求时间复杂度

最长的字符串长度为s；数组中有n个字符串

对每个字符串排序：Oslogs

将数组中的每一个字符串按照字母序排序：O(n*slogs)

将整个字符串数组按照字典序排序：O(s*nlogn)

答案：O(n*s*(logs+logn))

## 数据规模与时间复杂度

如果你想在1内解决问题:

最简单的指令：

O(n^2)的算法可以处理10^4级别的数据

O(^2)的算法可以处理10^8级别的数据

O(nlogn)的算法可以处理10^7的数据

## 空间复杂度

数组：On

二维数组：On^2

常数：O1

递归：O(深度)

## 递归调用的复杂度分析（主定理）

### 如果递归函数中，只进行一次递归调用

递归深度为depth

在每个递归函数中，时间复杂度为T

则总体时间复杂度为O(T*depth)

#### 例如：求幂操作

```c
double pow(double x,int n){
    assert(n >= );
    if(n == 0)
        return 1.0；
    double t = pow(x,n/2);
    if(n%2)
        return x*t*t;
    return t*t;
}
```

递归深度：n/2=1的次数：logn

每个递归的操作时间：2

总体时间复杂度：O(logn)

### 递归中进行多次递归调用

多次递归需要通过计算递归树上的节点个数来计算

调用次数：m(数据规模)

树的深度：n

m^0+m^1+m^2+...+m^n = m^(n+1)-1

或者层数*每一层的数据规模

也就是O(m^n)

可以用二叉树剪枝=>动态规划

