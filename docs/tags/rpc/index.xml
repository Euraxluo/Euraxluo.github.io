<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rpc on Euraxluo Blog</title>
    <link>/tags/rpc/</link>
    <description>Recent content in rpc on Euraxluo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright>
    <lastBuildDate>Mon, 22 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/rpc/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gRPC学习</title>
      <link>/posts/rpc/grpc%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/rpc/grpc%E5%AD%A6%E4%B9%A0/</guid>
      <description>gRPC概述   概览
gRPC是Google开发并开源的一套语言中立的RPC框架
  特点
 语言中立 基于IDL文件定义服务，通过proto3工具生成指定语言的数据结构，服务端接口以及客户端Stub 通信协议基于标准的HTTP/2设计，支持双向流，消息头压缩，单TCP的多路复用，服务端推送等特性，可以在移动端设备上更加省电和节省流量 序列化支持Protocol Buffer 和JSON协议，该协议是一种语言无关的高性能序列化框架    服务端创建流程 gRPC服务端java版本的实现使用了Build模式，对底层服务绑定，transportServer和NettyServer的创建和实例化都做了封装和屏蔽，让服务调用者不用关心gRPC的调用细节
整体流程分为3步：
 创建Netty HTTP/2服务端 将需要的服务端接口实现类注册到内容的Registy中，RPC调用时，可以根据RPC请求消息中的服务定义信息查询到服务接口实现类 创建gRPC Server，它是gRPC服务端的抽象，聚合了各种Listener，用于RPC消息的统一调度和处理  关键流程分析：
  NettyServer 实例创建：
首先需要初始化NettyServer，它是gRPC基于Netty4.1 HTTP/2协议栈上封装的HTTP/2 服务端。NettyServer构建完成后，监听指定的Socket地址，即可实现基于HTTP/2协议的消息头接入
  绑定IDL定义的服务接口实现类:
gRPC与其他很多RPC框架不同的是，服务接口实现类的调用并不是通过动态代理和反射机制，而是通过proto工具生成代码，在服务端启动时，将服务接口实现类实例注册到gRPC的内部服务注册中心上。当请求消息接入后，可以根据服务名和方法名，直接调用启动时注册的服务实例，而不需要通过反射的方式进行调用，性能更好
  gRPC服务实例（ServerImpl构建）:
ServerImpl负责整个gRPC服务端消息的调度和处理，创建ServerImpl实例过程中，会对服务端依赖的对象进行初始化，例如Netty的线程池资源，gRPC的线程池，内部的服务注册类（InternalHandlerRegitry）等，ServerImpl初始化完成后，就可以调用NettyServer的start方法启动HTTP/2服务端，接收gRPC客户端的服务调用请求
  服务端service调用流程 gRPC的客户端请求消息由Netty Http2ConnectionHandler接入，由gRPC负责将PB或者JSON消息反序列化为POJO对象，然后通过服务定义查询到该消息对应的接口实力，发起本地java接口调用。调用完成后，将响应消息序列化为对应和格式，通过HTTP2 Frame发送回客户端
整体流程分为4步：
 gRPC请求消息接入 gRPC消息头和消息体处理 内部的服务路由和调用 响应消息发送  关键流程分析
  gRPC请求消息接入
Netty通过底层的HTTP/2协议栈，通过Http2ConnectionHandler，实现了HTTP/2消息的统一接入和处理。gRPC通过注册Http2FrameListener监听器，回调接收HTTP2协议的消息数据。gRPC 通过 FrameListener 重载 Http2FrameListener 的 onDataRead、onHeadersRead 等方法，将Netty的HTTP/2消息转发到gRPC的NettyServerHandler中，实现基于HTTP/2的RPC请求消息接入
  gRPC 消息头处理</description>
    </item>
    
    <item>
      <title>net/rpc学习</title>
      <link>/posts/rpc/net_rpc%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/rpc/net_rpc%E5%AD%A6%E4%B9%A0/</guid>
      <description>server 学习 服务注册: 在进行rpc方法调用前,需要先进行方法注册
func (server *Server) register(rcvr interface{}, name string, useName bool) error { //整个工作就是构造service对象,填充属性  //最后调用`sync.Map.LoadOrStore(sname,s)`方法完成服务注册 	s := new(service) s.typ = reflect.TypeOf(rcvr) s.rcvr = reflect.ValueOf(rcvr) sname := reflect.Indirect(s.rcvr).Type().Name() if useName { sname = name } if sname == &amp;#34;&amp;#34; { s := &amp;#34;rpc.Register: no service name for type &amp;#34; + s.typ.String() log.Print(s) return errors.New(s) } if !token.IsExported(sname) &amp;amp;&amp;amp; !useName { s := &amp;#34;rpc.Register: type &amp;#34; + sname + &amp;#34; is not exported&amp;#34; log.</description>
    </item>
    
    <item>
      <title>RPC原理学习</title>
      <link>/posts/rpc/rpc%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/rpc/rpc%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0/</guid>
      <description>RPC原理解析 简介： RPC 的全称是 Remote Procedure Call，即远程过程调用
具有以下作用：
 屏蔽远程调用跟本地调用的区别，让我们感觉就是调用项目内的方法； 隐藏底层网络通信的复杂性，让我们更专注于业务逻辑。  TIPs:
 使用rpc的场景是否合适， 什么是否需要开启压缩，根据配置，根据部署机器配置，根据网络环境，根据传输数据大小 调用过程超时处理，以及失败重试机制，例如dubbo的failfast，failover等 服务集群注意点  服务注册，发现，服务注册中心 服务治理，服务分组，服务别名，服务限流，服务降级，服务调用链，链路跟踪 服务监控，调用链监控，方法监控，数据指标监控（TPS，调用量，可用率，调用返回时间，服务网络响应时间） 服务日志，聚合查询，整理，告警 服务集群化，分组化的在线配置中心。支持日志等级控制，服务控制    RPC通信流程： 步骤如下：
  RPC是远程调用，需要网络传输数据，并且由于常用于业务系统之间进行远程调用，所以需要使用TCP来进行传输
  网络传输的数据必须是二进制数据，但是调用方请求的出入参数都是对象，所以需要使用可逆的算法，来将对象转化为二进制数据，这一步叫做序列化
  调用方持续的将请求序列化为二进制数据，经过TCP后传输给了服务提供方。服务提供方如何知道请求的数据的大小，以及请求的是哪个接口类型；因此需要约定数据包的格式，这个步骤就是协议的约定
  根据协议格式，服务提供者可以正确的从二进制数据中分割出不同的请求，同事根据请求类型和序列化类型，把二进制的消息体逆向还原成请求对象，这一步就叫反序列化
  服务提供方根据反序列化出来的请求对象，找到对象的实现类，完成方法调用
  将执行结果序列化后，回写到TCP通道中。调用方获取到应答数据后，再进行反序列化得到Reponse数据，完成RPC调用
  简化调用链，利用反射或者其他方法让调用方在调用远程方法时，能够像调用本地接口一样
  RPC协议 RPC协议简介
  RPC请求在发送到网络中之前，需要将请求转为二进制数据，基于TCP连接和服务方通信，TCP链接会根据系统配置和TCP窗口大小，在同一个TCP链接中，对数据包进行拆分，合并。服务方需要正确处理TCP通道中的二进制数据。
  RPC协议是一种应用层协议，主要负责应用间的通信，相对于HTTP协议，需要的性能更高，并且RPC是有状态的协议，请求和响应一一对应。RPC一般会设计更加紧凑的私有协议
  RPC协议的设计
  消息边界语义：利用一个定长数据来保存整个请求协议体的大小；先读取固定长度的位置里面的值，得到协议体长度，再去读取整个协议体的数据
  协议数据序列化方法信息：利用定长的位置存储协议数据的序列化方式
  将整个协议分为协议头和协议体，得到定长协议头，该协议头是不可扩展的</description>
    </item>
    
  </channel>
</rss>
