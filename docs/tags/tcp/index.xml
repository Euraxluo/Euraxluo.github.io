<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TCP on Euraxluo Blog</title>
    <link>/tags/tcp/</link>
    <description>Recent content in TCP on Euraxluo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 21 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="/tags/tcp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>python socket编程</title>
      <link>/posts/python/python-socket/</link>
      <pubDate>Thu, 21 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/python/python-socket/</guid>
      <description>TCP的三次握手和四次挥手
三次握手: 为什么需要三次握手? 客户端:我可以发东西给你(确保客户端的发送能力) 服务器:我可以收到,你能收到么?(确保服务器的接受和发送) 客户端:我能收到!(确保能收到)
连接建立!
如果是四次握手? 没必要啊,第三次已经确认可以收到消息了
如果是两次握手? 当网络阻塞时,客户端会发送两次,第一次请求到达服务器的时间慢于第二次 如果当时通信结束,服务器又收到了第一次阻塞的消息,如果是两次握手,就会分配资源 然而客户端已经完成了通信,不需要再连接了,会造成资源的浪费和安全隐患
四次挥手: 客户端:我说完了,我想停止发送请求了 服务器:我知道你要停止发送了,我会停止接受消息 ( 服务器停止接受消息,但是可能还有很多待发送的消息
客户端:收到服务器的确认信息,于是默不作声,等待服务器发送完他的消息
) 服务器:我的东西全发完啦!,我想要停止发送消息啦! 客户端:我知道你也要停止发送了,我也要停止接收消息(实际上还等了两个最大周期才真正停止接收消息) ( 服务器:收到了客户端的确认消息,于是停止发送消息 )
关于tcp的博客 使用tcp和udp让进程之间进行通信
ip地址：用來標記網絡上的主機 動態端口：1024-65535的端口，用完就回收
tcp socket client的基本流程
import socket ##創建socket s = socket.socket(socket.af_inet,socket.sock_stream) ##使用 ipaddr = (&amp;#34;ip&amp;#34;,port)#服务器的ip addr s.connect(ipaddr)#连接服务器 ### 发送数据 send_msg = &amp;#34;sasa&amp;#34; s.send(send_msg.encode(&amp;#34;utf-8&amp;#34;)) ### 接受数据 recvData = s.rec(1024)#一次接收的字符数 print(&amp;#34;recved msg:&amp;#34;,recvData.decode(&amp;#34;&amp;#34;utf-8)) ##關閉 s.close() tcp server的基本过程
# socket创建套接字 tcp = socket.socket(socket.AF_INET,socket.SOCK_STREAM) # 绑定端口 tcp.bind((&amp;#34;127.1&amp;#34;,7788)) # 设置为被动监听 tcp.</description>
    </item>
    
  </channel>
</rss>
