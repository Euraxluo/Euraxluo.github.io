<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>distributed on Euraxluo Blog</title>
    <link>/posts/distributed/</link>
    <description>Recent content in distributed on Euraxluo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright>
    <lastBuildDate>Tue, 23 Nov 2021 00:00:00 +0000</lastBuildDate><atom:link href="/posts/distributed/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>分布式互斥</title>
      <link>/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86_%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>/posts/distributed/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86_%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5/</guid>
      <description>在分布式系统中，排他性的资源访问方式,就叫做分布式互斥（Distributed Mutual Exclusion）,而这种被互斥访问的共享资源，就叫做临界资源
分布式系统中解决分布式互斥主要有以下几种方式
集中式算法/中央服务器算法 我们引入一个协调者程序，得到一个分布式互斥算法。每个程序在需要访问临界资源时，先给协调者发送一个请求。 如果当前没有程序使用这个资源，协调者直接授权请求程序访问；否则，按照先来后到的顺序为请求程序“排一个号”。 如果有程序使用完资源，则通知协调者，协调者从“排号”的队列里取出排在最前面的请求，并给它发送授权消息。 拿到授权消息的程序，可以直接去访问临界资源。
集中式算法示意图：
如上图所示，协调者程序根据普通程序请求临界资源的顺序，将其放入请求队列中，依次发放授权，每个程序完成临界资源请求后，通知协调者释放授权，排队的下一次程序继续获得授权。
交互次数  向协调者发送请求授权信息 协调者向程序发放授权 程序使用完临界资源后，向协调者发送释放授权信息  优点 直观，简单，信息交互量少，易于实现
缺点  协调者会成为性能瓶颈，当普通程序很多时，协调者需要处理的消息数量会随着需要访问临界资源的程序数量线性增加 容易引发单点故障，当协调者故障时，会导致所有的程序都无法访问临界资源，导致整个系统不可用。  可改进点 通过将master节点集群化，来降低协调者单点故障时，系统的可用性
总结 集中式算法具有简单、易于实现的特点，但可用性、性能易受协调者影响。在可靠性和性能有一定保障的情况下，比如中央服务器计算能力强、性能高、故障率低，或者中央服务器进行了主备，主故障后备可以立马升为主，且数据可恢复的情况下，集中式算法可以适用于比较广泛的应用场景。
分布式算法/使用组播和逻辑时钟的算法 如何不引入协调者的情况下，实现对于临界资源的互斥访问呢。当一个程序要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，就可以访问临界资源。其中，请求消息需要包含所请求的资源，请求者id，发起请求的时间。
如图所示，程序 1、2、3 需要访问共享资源 A。在时间戳为 8 的时刻，程序 1 想要使用资源 A，于是向程序 2 和 3 发起使用资源 A 的申请，希望得到它们的同意。在时间戳为 12 的时刻，程序 3 想要使用资源 A，于是向程序 1 和 2 发起访问资源 A 的请求。
此时程序 2 暂时不访问资源 A，因此同意了程序 1 和 3 的资源访问请求。对于程序 3 来说，由于程序 1 提出请求的时间更早，因此同意程序 1 先使用资源，并等待程序 1 返回同意消息。</description>
    </item>
    
  </channel>
</rss>
