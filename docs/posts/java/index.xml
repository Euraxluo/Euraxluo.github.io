<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Euraxluo Blog</title>
    <link>https://euraxluo.gitee.io/blog/posts/java/</link>
    <description>Recent content in java on Euraxluo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright>
    <lastBuildDate>Thu, 22 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://euraxluo.gitee.io/blog/posts/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Servlet1</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/servlet1/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/servlet1/</guid>
      <description>Servlet HTTP协议 是客户端与服务器通信的一种方式
参考链接 request: 请求行请求头请求体 response: 响应行响应头响应体 Get: GET用于信息获取，而且应该是安全的和幂等的
  带上数据,在URL上面拼接
www.baidu.com
name = zhanshan
age = 18
url:www.baidu.com?name = zhanshan&amp;amp;age = 18
url可见
  传输方式
HTTP header
  设计目的
获取数据
  具有安全隐患,GET方法不会改变服务器端数据，所以不会产生副作用
  GET请求返回的内容可以被浏览器缓存起来
  Post:   以流的方式传输,数据无限制
url不可见
  传输方式
HTTP body
  设计目的
发送数据
  用户可能会提交一些错误的数据
  浏览器不会缓存POST请求返回的内容
  ####　幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。</description>
    </item>
    
    <item>
      <title>Servlet2</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/servlet2/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/servlet2/</guid>
      <description>Cookie和Session 会话：浏览器发出http请求。服务器接受，对请求进行响应，浏览器接受http响应
Cookie 把会话数据保存在浏览器客户端
服务器第一次访问时，服务端生成cookie，并且把这个cookie通过响应，发送给客户端，客户端把cookie保存下来，以便在最近的下一次访问中使用
缺点
  Cookie有大小和数量的限制
  明文传递有风险
  //创建Cookie对象  Cookie userNameCookie = new Cookie(&amp;#34;userName&amp;#34;,userName); Cookie userPasswordCookie = new Cookie(&amp;#34;userPassword&amp;#34;,userPassword); //返回给访问对象  resp.addCookie(userNameCookie); resp.addCookie(userPasswordCookie); /、对外部浏览器返回的响应头进行处理 Cookie[] cookies = req.getCookies(); if(cookies != null){ for(Cookie cookie:cookies){ if (cookie.getName().equals(&amp;#34;userName&amp;#34;)) { userName = cookie.getValue(); }else if (cookie.getName().equals(&amp;#34;userPassword&amp;#34;)) { userPassword = cookie.getValue(); } } } 例子一 显示最近访问的时间。   判断账号是否正确
  如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。
  如果找到的对象为空，表明是第一次登录。那么要添加cookie
  如果找到的对象不为空， 表明不是第一次登录。</description>
    </item>
    
    <item>
      <title>WebSocket</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/websocket/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/websocket/</guid>
      <description>WebSocket 一、概念 1.WebSocket 是HTTP协议的补充。使用的TCP协议建立连接
2.HTML5是指一系列新API，新协议，WebSocket也是其中之一
二、优点 1.WebSocket是持久化协议，每次通信只需要一次连接
2.HTTP中一个request只能有一个response
3.连接过程：进行握手时，使用http协议对服务器发起连接请求，并且升级为websocket协议，确定后服务器建立连接，并且继续使用Websocket
三、作用 1.实现实时信息传递的其他方式
​	(1).ajax轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息
​	(2).HTTP long poll：客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。
​	(3).缺点：
​	ajax轮询：需要服务器有很快的处理速度和资源。（速度）
​	long poll：需要有很高的并发，也就是说同时接待客户的能力。（资源大小）
2.服务器完成协议升级后（HTTP-&amp;gt;Websocket），服务端就可以主动推送信息给客户端啦
3.整个通讯过程是建立在一次连接/状态中，避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求
四、特点 1.建立在 TCP 协议之上，服务器端的实现比较容易。
2.与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
3.数据格式比较轻量，性能开销小，通信高效。
4.可以发送文本，也可以发送二进制数据。
5.没有同源限制，客户端可以与任意服务器通信。
6.协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。
五、客户端 1.创建WebSocket对象： var Socket = new WebSocket(url,[protocol])
url = 服务器地址，protocol是可接受的子协议
2.属性： (1)Socket.readyState//表示连接状态：0：尚未连接，1：已经连接，2：连接正在关闭，3：连接已经关闭，或不能打开。
(2)Socket.buffererdAmount//表示send()放在队列正在队列中等待传输
3.事件： | 对象触发的程序 | 描述 |
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; |
| Socket.onopen | 连接建立时触发 |</description>
    </item>
    
    <item>
      <title>XML</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/xml/</link>
      <pubDate>Thu, 22 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/xml/</guid>
      <description>Xml Xml  eXtendsible markup language 可扩展的标记语言
 XML 有什么用?   可以用来保存数据
  可以用来做配置文件
  数据传输载体
  定义xml  其实就是一个文件，文件的后缀为 .xml
 文档声明   简单声明， version : 解析这个xml的时候，使用什么版本的解析器解析
 `&amp;lt;?xml version=&amp;quot;1.0&amp;quot; ?&amp;gt;`   encoding : 解析xml中的文字的时候，使用什么编码来翻译
 `&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;gbk&amp;quot; ?&amp;gt;`   standalone : no - 该文档会依赖关联其他文档 ， yes&amp;ndash; 这是一个独立的文档
 `&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;gbk&amp;quot; standalone=&amp;quot;no&amp;quot; ?&amp;gt;`   encoding详解 在解析这个xml的时候，使用什么编码去解析。 ---解码。  文本存储时不直接存储文字， 而是存储这些文字对应的二进制 。 那么这些文字对应的二进制到底是多少呢？ 根据文件使用的编码 来得到。</description>
    </item>
    
    <item>
      <title>JDBC1</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/jdbc1/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/jdbc1/</guid>
      <description>jdbc  JAVA Database Connectivity java 数据库连接
  为什么会出现JDBC   SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且java语言使用比较广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的java程序只要使用sun公司提供的jdbc驱动即可。
 jdbc是一种接口规范
优势:
  简单
  快捷
  移植性
  框架(在jdbc的基础上开发更好的框架)
  jdbc Manager的上层JDBC API负责与java Application通信,JDBC Driver API 负责与具体的数据库通信(由数据库厂商开发和提供)
API介绍: Driver:接口,定义了各个驱动程序都必须要实现的功能
DriverManager:Driver的管理类
用户通过Class.forname(DriverName)可以向DriverManager注册一个驱动程序,然后使用getConnection来建立物理连接,基于物理连接没使用SQL语句
eg:
Class.forName(JDBC_DRIVER); conn= DriverManager.getConnection(DB_URL,USER,PASS); //DB_URL:链接,USER:用户名,PASS:密码  //例如  conn= DriverManager.getConnection(&amp;#34;jdbc:mysql://127.0.0.1:3306/test&amp;#34; ,USER,PASS); //jdbc:mysql://ip:端口/数据库名;协议:子协议:主机ip:端口/数据库  常用的3种格式  mysql  jdbc:mysql://&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;/database
oracle  jdbc:oracle:thin:@&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;:database
sqlserver  jdbc:microsoft:sqlserver://&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;;DatabaseName=database
Connection 常用方法   Statement对象</description>
    </item>
    
    <item>
      <title>JDBC2</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/jdbc2/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/jdbc2/</guid>
      <description>业务场景1  过滤条件比较弱,一次读出多条记录 读取数据库表中的所有记录 海量数据读取  这些都容易产生内存溢出,为了不使得内存溢出,我们采用游标的方式
游标:提供一种客户端读取部分服务器端结果集的机制 一个批次的大小为:Fetch Size
游标的使用  开启游标,DB_URL的处理(加上useCursorFetch=true)  eg:
jdbc:mysql://&amp;lt;ip&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;database&amp;gt;?useCursorFetch=true
 使用PreparedStatement接口
PreparedStatement接口继承自Statement接口,我们可以使用PreparedStatement替代Statement
  这个接口要求创建时就要传入sql语句,但是这个sql语句,参数格式化.即过滤条件用问号表示,后续再用PreparedStatement.setString()和PreparedStatement.setInt()来设置过滤条件.还可以使用PreparedStatement.setFetchSize()设置游标的大小.即每次从数据库服务端取回记录的数量
eg:
//使用prepareStatement()接口  ptmt = conn.prepareStatement(&amp;#34;select * from user&amp;#34;); ptmt.setFetchSize(1); rs = ptmt.executeQuery(); 业务场景2  读取的记录字段太大(例如博文)  也是会造成内存溢出,即使读取的记录很少
流方式 把大字段按照二进制流的方式,分成多个区间,每次只读取一个区间的内容
流方式的使用   利用ResultSet.getBinaryStream();获取对象流
  生成一个外部文件,把对象流采用边读边写的方式写入文件
  eg:
while(rs2.next()){ //5.获取对象流  InputStream in = rs1.getBinaryStream(&amp;#34;userName&amp;#34;); //6.将对象流写入文件  File f = new File(FTLE_URL); OutputStream out = null; try { out = new FileOutputStream(f); int temp = 0; while((temp = in.</description>
    </item>
    
    <item>
      <title>JDBC3</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/jdbc3/</link>
      <pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/jdbc3/</guid>
      <description>1. execute,executeQuery,executeUdate的区别 JDBCTM中Statement接口提供的execute,executeQuery,executeUdate之间的区别:
  executeQuery:
用于产生单个结果集的语句,例如SELECT语句,使用最多的方法
  executeUpdate:
用于执行INSERT,UPDATE,DELETE语句以及DDL语言,返回值是一个整数,指示受影响的行
  execute:
用于执行返回多个结果集,多个更新技术或者两者皆有的语句
  2. SQL注入 防范措施:
  使用动态封装的方式会导致SQL注入的风险,我们应该使用prepareStatement提供的参数化SQL
  严格的数据库权限管理
 仅给web应用访问数据库的最小权限
  避免Drop table等权限
   封装数据库错误
 不要直接将后端数据库异常信息暴露给用户
  对后端遗产信息进行必要的封装,避免用户直接看到后端异常
   机密信息禁止明文存储
 涉密信息需要加密处理
  使用AES_ENCRYPT/AES_DECRYPT加密和解密
   事务:{是并发控制的基本单位,指作为单个逻辑工作单位执行的一系列操作,而这些逻辑工作单元需要满足ACID特性} ACID:原子性,一致性,隔离性,持久性
jdbc事务控制 connection:
 .setAutoCommit(&#39;false&#39;)开启事务
  .commit()事务执行结束提交事务
  .rollback()回滚到事务开始之前的状态
 eg:
try{ conn = JDCBUtil.</description>
    </item>
    
    <item>
      <title>JSP</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/jsp%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/jsp%E5%AD%A6%E4%B9%A0/</guid>
      <description>jsp  Java Server Page
  什么是jsp   从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet.
  为什么会有jsp?   html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。 这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码 ， jsp里面可以写java代码。
 java服务器页面
 jsp = html+java+JSP tag   处理流程：浏览器客户端向服务器发起请求，请求对应的jsp文件。然后jsp容器载入jsp文件，并且把jsp文件转化为Servlet(只是简单的把jsp文件改写为servlet语句)，然后jsp容器把servlet编译为可执行的class，然后把请求交给servlet容器，然后web组件就会调用servlet容器，载入对应的servlet实例。在执行时，会产生html页面，嵌入到response中返回给浏览器
 ###　jsp与servlet比较
１.	侧重点
​	jsp侧重于视图
​	servlet侧重于逻辑
２.	jsp有一些内置对象
３.	本质jsp其实是servlet的一种简化
###　jsp基本语法
 jsp声明  &amp;lt;%! int a,b,c; %&amp;gt;
jsp表达式(表达式元素中可以包含任何符合java语言规范的表达式，但是不能使用分号来结束)  &amp;lt;%= 表达式%&amp;gt;</description>
    </item>
    
    <item>
      <title>MyBatis</title>
      <link>https://euraxluo.gitee.io/blog/posts/java/mbatis%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 29 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://euraxluo.gitee.io/blog/posts/java/mbatis%E5%9F%BA%E7%A1%80/</guid>
      <description>MyBatis   一个ORM框架,(不直接建立java对象到关系数据库表数据的映射,而是建立对对象的操作方法到SQL的映射)支持自定义SQL,存储过程和高级映射的持久化框架
  使用XML或者注解配置
  能够映射基本数据元素,接口,Java对象到数据库
  ORM(Object/Relation Mapping) 作用:持久化类与数据库表之间的映射关系,让我们对持久化对象的操作自动转换成对关系数据库操作
通过映射,我们把关系数据库中的每一行都映射为对象,数据库的每一列就映射成了对象的属性
##　三层架构：
１.	接口层(数据查询接口,数据新增接口,数据更新接口,数据删除接口,获取配置接口)
２.	数据处理层(参数映射,SQL解析,SQL执行,结果映射)
３.	基础支撑层(连接管理，事务管理，配置加载，缓存处理)
工作流机制:   根据XM(xml中定义了连接的地址,以及对象和SQL的映射和关系)L或者注解加载SQL语句,参数映射,结果映射到内存
  应用程序调用API传入参数和SQL ID
  MyBatis 自动生成SQL语句完成数据库访问,转换执行结构返回应用程序
  例如,完成一个数据库查询  加载配置文件   应用配置文件
  关联映射文件
 sqlSession   生成SqlSessionFactory
  获取SqlSession
 执行查询   Session 执行SQL
 </description>
    </item>
    
  </channel>
</rss>
