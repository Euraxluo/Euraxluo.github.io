<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>redis on Euraxluo Blog</title>
    <link>/categories/redis/</link>
    <description>Recent content in redis on Euraxluo Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright>
    <lastBuildDate>Sun, 10 Mar 2019 00:00:00 +0000</lastBuildDate><atom:link href="/categories/redis/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Redis API及数据结构</title>
      <link>/posts/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;本文介绍了redisApi以及数据结构&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Redis Cluster</title>
      <link>/posts/redis/rediscluster-1/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/rediscluster-1/</guid>
      <description>Redis Cluster 背景   并发量 &amp;lt;10万dps
  数据量 单机内存&amp;lt;256G
  带宽 网卡限制
  解决方式   提高机器配置
  分布式
  数据分布 | 分布方式 | 特点 | 典型产品 |
| &amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash; | &amp;mdash;&amp;mdash;&amp;ndash; |
| 哈希分布 | 数据分散度高数据分布业务无关无法顺序访问支持批量操作 | 一致性哈希MemcacheRedis Cluster缓存产品 |
| 顺序分布 | 数据分散度易倾斜键值业务相关可顺序访问支持批量操作 | BigTableHBase |
哈希分布  节点取余：hash(key)%nodes    客户端分片：哈希+取余
  节点扩容：扩容时需要数据迁移
  翻倍扩容：扩容时最好多倍扩容
  一致性哈希  有一个token环，节点在token环上，会为每个key分配一个token，在依据token在环上顺时针寻找最近的节点</description>
    </item>
    
    <item>
      <title>Redis Cluster 2</title>
      <link>/posts/redis/rediscluster-2/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/rediscluster-2/</guid>
      <description>集群伸缩 伸缩原理 伸：增加节点 缩：节点下线
集群伸缩：槽和数据在节点之间的移动
扩容集群  准备新节点    打开集群模式
  配置和其他节点统一
  启动后是孤立的节点
  加入集群meet    在集群节点中配置：cluster meet 127.1 &amp;lt;newnodeport&amp;gt;
  使用redis-trib.rb：
  redis-trib.rb ad-node new_host:new_port existing_host:existing_port --slave --master_id &amp;lt;arg&amp;gt;{扩展参数是配置为从节点}
  为它迁移槽和数据可以实现扩容
  可以作为从节点负责故障转移
  迁移槽和数据    1). 对目标节点发送cluster setslot &amp;lt;slot&amp;gt; importing &amp;lt;sourceNodeId&amp;gt;,让目标节点准备导入槽的数据
  2). 对源节点发送cluster setslot &amp;lt;slot&amp;gt; migrating &amp;lt;targetNodeId&amp;gt;,让源节点准备迁出槽
  3). 源节点循环执行cluster getkeysinslot &amp;lt;slot&amp;gt; &amp;lt;count&amp;gt;,每次获取count个属于槽的键</description>
    </item>
    
    <item>
      <title>Redis Cluster 3</title>
      <link>/posts/redis/rediscluster-3/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/rediscluster-3/</guid>
      <description>RedisCluster 客户端使用 moved重定向   对任意节点发送键命令
  节点会计算槽和对应节点确定这个键是否指向自身
  如果指向自身，就执行命令，返回key所在的槽
  否则就回复moved异常，客户端拿到这个moved后，重定向节点，重新发送命令
  ASK重定向 解决槽迁移时客户端的查询问题
  对源节点发送键命令
  节点发现正在进行槽迁移，回复客户端ask转向
  客户端对目标节点Asking，发送命令
  目标节点返回响应结果
  两者的区别   两者都是客户端重定向
  moved：槽已经确定迁移
  ask：槽还在迁移中
  smart客户端 目标：追求性能（不能使用代理模式）
  从集群中选取一个可运行节点，使用cluster slots 初始化槽和节点映射
  将cluster slots的结果映射到本地，为每个节点都创建一个连接池
  准备执行命令
  执行命令   通过key哈希模16383，得到slot，通过本地映射得到节点，再通过连接池去连接
  如果连接出错，可能槽迁移，也可能是连接异常，如果槽迁移，那么
  我们随机访问一个活跃节点，节点会返回moved异常</description>
    </item>
    
    <item>
      <title>Redis Sentinel</title>
      <link>/posts/redis/redissentinel/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redissentinel/</guid>
      <description>Redis Sentinel 主从复制的问题   手动故障转移
  写能力和存储能力受限
  Redis Sentinel架构   有多个Sentinel节点
  不用来存储数据
  多个节点判断master节点的故障，进行故障转移
  保证高可用，即便一个Sentinel节点挂点也没事
  客户端只会记录sentinel的地址（因为sentinel会进行故障转移，master节点地址不固定）
  一套sentinel可以监控多套master-slave，利用master-name作为标识
  Sentinel的故障转移   多个sentinel发现并确认master有问题
  选举出一个sentinel作为领导
  选出一个slave作为新的master
  通知其余slave成为新的master的slave
  通知客户端主从变化
  等待老的master复活成为新的master的slave
  安装与配置 主从配置：
sed &amp;quot;s/6380/6381/g&amp;quot; redis-6380.conf &amp;gt; redis-6381.conf
查看：
cat redis-6381.conf|grep -v &amp;quot;#&amp;quot; |grep -v &amp;quot;^$&amp;quot;
Sentinel配置</description>
    </item>
    
    <item>
      <title>Redis基础学习</title>
      <link>/posts/redis/redis%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E5%9F%BA%E7%A1%80/</guid>
      <description>Redis基础学习 Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set &amp;ndash;有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。
安装和基本命令 安装： Ubuntu18.04：sudo apt-get install redis-server
安装redis后会自动安装redis-cli
也可以安装图形工具
sudo snap install redis-desktop-manager
基本操作  检查Redis服务器系统进程  ps -aux |grep redis
通过启动命令检查Redis服务器状态  netstat -nlt|grep 6379
访问Redis  最简启动
redis-server
指定配置文件启动
redis-server config/redis-6380.conf
验证
ps -ef|grep redis
netstat -antpl | grep redis
redis-cli -h ip -p port ping
访问
redis-cli -a euraxluo -h 127.1 -p 6379
基本命令 0.keys* 时间复杂度是On
keys xx?
keys xx*</description>
    </item>
    
    <item>
      <title>Redis的主从复制</title>
      <link>/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>Redis的主从复制 单机部署的问题   机器故障（高可用）
  容量瓶颈（分布式）
  QPS瓶颈（分布式）
  主从复制的作用   为一个数据提供了副本
  slave从master复制一个备份库
  master可以有多个slave
  一个slave只能有一个master
  数据流向是单向的，由master&amp;ndash;&amp;gt;slave
  扩展读性能，可以实现读写分离
  主从复制实现 slaveof slaveof 127.1 6380
取消复制
slaveof no one
配置 #配置这个redis服务复制ip:port这个redis作为他的slave slaveof ip port #只读,必须保证从和主的内容一致 slave-read-only yes 两种方式的比较 | 方式 | 命令 | 配置 |
| &amp;mdash;- | &amp;mdash;&amp;mdash;&amp;mdash;- | &amp;mdash;&amp;mdash;&amp;ndash; |
| 优点 | 无需重启 | 统一配置 |</description>
    </item>
    
    <item>
      <title>Redis的持久化</title>
      <link>/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AD%96%E7%95%A5/</guid>
      <description>Redis的持久化 Redis持久化作用 什么是持久化 redis的所有数据保存在内存中，对数据的更新回异步的保存在磁盘中
持久化方式 快照   MySQL Dump
  Redis RDB
  日志   MySQL Binlog
  Hbase HLog
  Redis AOF
  RDB持久化 什么是RDB redis可以通过命令，把当前数据库的状态保为一个RDB文件（二进制）
也可以通过命令把硬盘上的RDB载入到redis中
同时RDB文件也是一个复制的媒介
触发机制 save   通过save命令让redis生成rdb文件，生成成功返回‘OK’
  同步命令，阻塞命令，会导致服务器阻塞
  会替换老的rdb文件
  复杂度On
  bgsave   接收到bgsave后，redis利用linux的fork()命令产生一个子进程，让产生的子进程去生成RDB文件，返回‘Backgroud saving started’
  fork()函数也是一阻塞命令，一般情况下很快
  会替换老的rdb文件
  复杂度On
  save与bgsave比较 | 命令 | save | bgsave |</description>
    </item>
    
    <item>
      <title>Redis高级特性初识别</title>
      <link>/posts/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <description>Redis高级特性初识 慢查询 客户端请求的生命周期   客户端发送命令
  入队列
  执行命令（慢查询在这一阶段）
  返回客户端
  （客户端超时，不一定是慢查询，慢查询只是客户端超时的一个可能）
配置   slowlog-max-len，固定长度
  slowlog-log-slower-than，慢查询阈值（单位微秒）
=0，记录所有命令
&amp;lt;0，不记录任何命令
  #1. 第一次开启配置 config get slowlog-max-len = 128 config get slowlog-log-slower-than = 10000 #2. 修改默认配置重启 #3. 动态配置 config set slowlog-max-len = 128 config set slowlog-log-slower-than = 10000 API 慢查询会把命令放在内存中
  slowlog get [n]：获取慢查询队列
  slowlog len ：获取慢查询队列长度
  slowlog reset：清空慢查询队列</description>
    </item>
    
    <item>
      <title>Redis基础配置</title>
      <link>/posts/redis/redis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>/posts/redis/redis%E9%85%8D%E7%BD%AE/</guid>
      <description>Redis的特点 速度快   使用内存
  使用C语言
  单线程
  持久化  对数据的更新，异步保存到磁盘上  多种数据结构   strings/Blobs/Bitmaps
  Hash Tables
  Linked Lists
  Sets
  Sorted Sets
  BitMaps
  HyperLogLog(超小内存唯一值计数)
  GEO
  多语言支持 功能丰富   发布topic
  支持lua脚本
  支持简单的事务
  支持pipeline
  高可用，分布式 Redis初识   缓存
  计数器</description>
    </item>
    
  </channel>
</rss>
