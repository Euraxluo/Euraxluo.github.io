---
layout:     post                    # 使用的布局（不需要改）
title:      java學習               # 标题 
subtitle:   匿名內部類                #副标题
date:       2018-11-10             # 时间
author:     Euraxluo                      # 作者
header-img: img/post-bg-github-cup.jpg  #这篇文章标题背景图片
catalog: true                 # 是否归档
tags:                               #标签
    - java

---
## 匿名内部类
概念：即内部类的简化写法
前提：存在一个类（可以是具体类也可以是抽象类）或接口
格式：new 类名或接口名{重写的方法}
本质：创建的是继承了类或实现了接口的子类匿名对 象。
Java语言规范上是这么描述匿名类的：

## 匿名类的声明：

>匿名类的声明是由java编译器自动派生自一个类实例创建表达式。
匿名类永远不能是抽象的。
匿名类总是隐式的final。
匿名类总是一个内部类；并且不能是static的。
匿名构造函数：

匿名类不能有显式声明的构造函数。相反的，Java编译器必须为这个匿名类自动提供一个匿名构造函数。匿名类Ｃ继承于父类Ｓ那么匿名构造函数是下面的形式：

如果Ｓ不是一个内部类或者Ｓ是一个静态上下文中的局部类，那么这个匿名构造函数有一个形参为每一个在Ｃ的类实例创建表达式中的实际参数。 
类的实例创建表达式的实际参数用来确定S的一个构造函数cs，使用方法调用相同的规则。 
每一个匿名构造函数的形参必须和cs中的相关形参一致。 
这个构造函数中显式的包括super(…)构造函数调用，这个实际参数是构造函数的形参，按它们声明的顺序。

否则，Ｃ的构造函数第一个形参描述了这个值，直接包围实例ｉ相对于Ｓ。参数的类型是Ｓ的class类型。 
构造函数有一个额外的形参为每一个类实例创建语句声明在匿名类中的实际参数。第n个形参和第n-1个实际参数相关。 
类的实例创建表达式的实际参数用来确定S的一个构造函数cs，使用方法调用相同的规则。 
每一个匿名构造函数的形参必须和cs中的相关形参一致。 
这个构造函数中显式的包括super(…)构造函数调用，这个实际参数是构造函数的形参，按它们声明的顺序。

在所有的情况下，匿名构造函数的throws语句必须列出所有的检查异常，包括父类构造函数显式调用语句抛出的和匿名类的实例初始化或者变量初始化抛出的异常。

> 注意：匿名构造函数的签名涉及到了一个不可达类型是可能的(例如，出现在父类构造函数中的类型)，这不会导致任何编译时和运行时错误。

## 实际使用中我们只需注意这几点： 
1. 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 
2. 匿名内部类中是不能定义构造函数的。 
3. 匿名内部类中不能存在任何的静态成员变量和静态方法。 
4. 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 
5. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。

## 编译时的命名规则：

内部类的class文件命名是：主类＋$＋内部类名
匿名类的class文件命名是：主类＋$＋(1,2,3….)
匿名类的语法

Runnable hello = new Runnable() {  
​    public void run() {  
​        System.out.println("hello");  
​    }  
};

## 一个匿名类由以下几个部分组成：

### new操作符
Runnable：接口名称。这里还可以填写抽象类、普通类的名称。
()：这个括号表示构造函数的参数列表。由于Runnable是一个接口，没有构造函数，所以这里填一个空的括号表示没有参数。
{…}：大括号中间的代码表示这个类内部的一些结构。在这里可以定义变量名称、方法。跟普通的类一样。
### 访问权限 
1. 访问外层Class里面的字段。 
2. 不能访问外层方法中的本地变量。除非变量是final。 
3. 如果内部类的名称和外面能访问的名称相同，则会把名称覆盖掉。 
4. 不能定义静态初始化代码块 
5. 不能在匿名类里面定义接口 
6. 不能在匿名类中定义构造函数

因为匿名类没有名字，而构造函数需要把类名作为方法名才能看成构造函数。 
### 匿名类中可以包含的东西有：

字段
方法
实例初始化代码
本地类

### 匿名内部类方法的访问:
```java
//方法1：直接在new A内部类后边加点加方法，这样访问，如果方法多了，调用太麻烦
new D(){
​    @Override
​    public void ShowContext() {
​        System.out.println("hello");
​    }
}.ShowContext();
```
```java
//方法2：通过创建对象来访问，多态思想
D a=new D(){
​    @Override
​    public void ShowContext() {
​        System.out.println("hello");
​    }
};
a.ShowContext();
```

### 匿名内部类在开发中的使用，一般是方法参数为接口的情况
```java
interface D{
​    void ShowContext();
}
class B{
​    //参数为接口对象
​    public void show(D d) {
​        d.ShowContext();
​    }
}

public class niming {
​    public static void main(String[]args) {
​        B b=new B();
​        //调用时使用匿名类创建匿名对象
​        b.show(new D(){
​            @Override
​            public void ShowContext() {
​                System.out.println("hello");
​            }
​        });
​    }
}
```
