---
layout:   post          
title:   05-14作业 
date:    2018-05-14       
author:   Euraxluo           
categories: java
tags:  线程
---
* TOC
{:toc}



#1编写三个线程，分别设置不同优先级，并测试启动

+ 代码

```java

import java.util.concurrent.Executor;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;



public class homework514 {

    //run()在完成时不会返回值，Callable接口的call()会产生返回值

    public static class Run_test implements Runnable{//使用Runnable接口的run()方法

        private static int taskCount = 0;

        private int priority;

        private final int id = taskCount++;//线程id

        public Run_test(int priority){

            this.priority = priority;

        }

        public String dispaly(){//多线程就应该在run里面输出

            return "线程id:"+id+"优先级:"+priority;

        }

        public void run(){

            Thread.currentThread().setPriority(priority);

            System.out.println(dispaly());

            Thread.yield();//线程调度器

        }

    }



    public static void main(String[] args)

    {



    /*

        for(int i=1;i<=5;i++)//未设置优先级

        {

            Thread t = new Thread(new Run_test());//提交给Thread构造器

            t.start();

        }

        */

    /*

        //创建一个线程集

        ExecutorService exec = Executors.newFixedThreadPool(5);//预先限制数量

        for(int i=1;i<=5;i++){

            exec.execute(new Run_test());

        }

        exec.shutdown();

        */

    /*

        //序列化线程，每一个线程会在下一个线程运行前结束

        ExecutorService exec = Executors.newSingleThreadExecutor();//预先限制数量

        for(int i=1;i<=5;i++){

            exec.execute(new Run_test());

        }

        exec.shutdown();

        */



        //设置线程优先级

        ExecutorService exec = Executors.newCachedThreadPool();

        exec.execute(new Run_test(Thread.MAX_PRIORITY));//10

        exec.execute(new Run_test(Thread.MIN_PRIORITY));//1

        exec.execute(new Run_test(Thread.NORM_PRIORITY));//5

        exec.shutdown();

     



    }

}



```

#2利用sleep方法编写一个倒计时程序



+ 代码

```java

public class homework514 {

    //定义任务

    //使用Runnable接口的run()方法

    public static class Run_test implements Runnable{

        private int countDown;



        public Run_test(int countDown){//倒计时数字

            this.countDown = countDown;

        }

        public String dispaly(){//多线程就应该在run里面输出

            return ""+(countDown>0?countDown:"GO!");



        }

        public void run(){

            while(countDown-- > 0){

                System.out.println(dispaly());

                try {

                    Thread.sleep(1000);

                } catch (InterruptedException e) {

                    e.printStackTrace();

                }

            }

        }

    }

    public static void main(String[] args)

    {

        Run_test countdown = new Run_test(20);

        countdown.run();

    }

}



```



  



#3继承Thread并重写run方法、实现Runnable接口,单独定义线程任务



+ 代码

```java

import java.util.concurrent.Executor;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;



public class homework514 {

    //run()在完成时不会返回值，Callable接口的call()会产生返回值

    public static class Run_test implements Runnable{//使用Runnable接口的run()方法{多线程合作完成任务}

        private static int taskCount = 0;

        private int priority;

        private final int id = taskCount++;//线程id

        public Run_test(int priority){

            this.priority = priority;

        }

        public String dispaly(){//多线程就应该在run里面输出

            return "线程id:"+id+"优先级:"+priority;

        }

        public void run(){

            Thread.currentThread().setPriority(priority);//run()中是多个线程需要完成的任务

            System.out.println(dispaly());

            Thread.yield();//线程调度器

        }

    }



    static class Runner_extend_test extends Thread{//多线程各自完成任务

        private int countDown=5;

        private String name;

        public Runner_extend_test(String name){

            this.name = name;

        }//以倒计时为例子

        public String dispaly(){//多线程就应该在run里面输出

            return name+":"+(countDown>0?countDown:"GO!");



        }

        public void run() {

            while (countDown-- > 0) {

                System.out.println(dispaly());

            }

        }



    }



    public static void main(String[] args)

    {

        //启动继承Thread的线程

        Runner_extend_test run_1=new Runner_extend_test("线程1");

        Runner_extend_test run_2=new Runner_extend_test("线程2");

        Runner_extend_test run_3=new Runner_extend_test("线程3");



        run_1.start();

        run_2.start();

        run_3.start();

    }

}

 

```

#4获取线程相关信息的方法



+ 代码

```java



    public static Thread getThreadName(String threadName) {

        Thread  t = new Thread(threadName);

        while(true){

            //根据线程名取得线程

            if (t.getName().equals(threadName)){



                return t;

            }

            return null;

        }

    }

```

#5聊天室服务端： 本次改进,通过多线程使得服务端可以支持多个客户端同时连接



+ 代码

```java

import java.io.*;

import java.net.InetAddress;

import java.net.ServerSocket;

import java.net.Socket;

import java.util.Scanner;

import java.util.concurrent.ExecutorService;

import java.util.concurrent.Executors;



public class MyServerSocket {

    private ServerSocket server;

    private Socket socket;

    public int m=10000;

    String message = null;

    public  int n = 0;

    ExecutorService pool = Executors.newFixedThreadPool(50);//创建一个最大容量为50的线程池，为每一个入站连接分配一条线程。



    public MyServerSocket() {

        try {

            server = new ServerSocket(233);/*指定端口*/

        } catch (Exception e) {

            System.out.println("端口被占用");

            System.exit(0);

        }

    }



    public void start() {

        try {

            System.out.println("等待客户端连接...");

            while (true) {

                socket = server.accept();//监听端口

                System.out.println("一个客户端连接成功！");

                //线程池中拿取一条线程来处理socket连接。然后主程序运行下一个循环，继续等待下一个客户端的访问。

                pool.execute(

                        new Runnable() {

                            @Override

                            public void run() {

                                GetClient(socket);

                                n++;

                            }}

                            );



                OutputToClient otc = new OutputToClient();

                new Thread(otc).start();

            }



        } catch (Exception e) {

            System.out.println("一个客户端连接失败！");

        }finally {

            pool.shutdownNow();

        }

    }



    public static void main(String[] args) {

        MyServerSocket server = new MyServerSocket();

        server.start();

    }

    static void GetClient(Socket socket){

        InetAddress host;

        host = socket.getInetAddress();

        Scanner put_in = new Scanner(System.in);

        try{

            InputStream input = socket.getInputStream();

            InputStreamReader isr = new InputStreamReader(input,"utf-8");

            BufferedReader in = new BufferedReader(isr);

            /*客户端信息流*/

            String message = null;

            while((message=in.readLine())!=null){

                boolean flg2 = message.endsWith("bye");

                System.out.println("["+host+"]说:"+message);

                if(flg2)

                {

                    System.out.println("客户断开连接！");

                    break;

                }

            }

            in.close();

        }catch (Exception e){

            System.out.println("客户断开连接！");

            System.exit(0);

        }finally {

            if(socket!=null){

                try{

                    socket.close();

                } catch (IOException e){

                    System.out.println("服务无法关闭！");

                }

            }

        }

    }



    private class OutputToClient extends Thread{

        Scanner input = new Scanner(System.in);

        OutputStream out = socket.getOutputStream();

        OutputStreamWriter osw = new OutputStreamWriter(out,"utf-8");

        PrintWriter pw = new PrintWriter(osw,true);



        private OutputToClient() throws IOException {

            pw.println("欢迎客户连接！结束通话输入bye");

//            pw.println("线程运行次数："+n);

        }

        public void run(){

            while(true) {

                System.out.println("服务器输入：");

                String message = input.nextLine();

                pw.println(message);}

        }

    }





}





```
