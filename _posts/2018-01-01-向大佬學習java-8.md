---
layout:   post          
title:   lambda
date:    2018-01-01    
author:   Euraxluo           
categories: java
tags:  表达式
---
* TOC
{:toc}


### 一 用lambda表达式实现Runnable
```
// Java8之前
        new Thread(new Runnable(){

            @Override

            public void run(){

                System.out.println("Before ava8,it's too code.");

            }

        }).start();

        // Java8之后

        new Thread(()-> System.out.println("This is java8！")).start();

```

* 语法介绍

```

(params) -> expression

(params) -> statement

(params) -> { statements }

```

* 如果不对方法进入重写，修改

`

() -> System.out.println("Hello Lambda Expressions");

`

### 二 使用Java 8 lambda表达式进行事件处理

```

      JButton jButton =new JButton("show");

        // Java8之前

        jButton.addActionListener(new ActionListener() {

            @Override

            public void actionPerformed(ActionEvent e) {

                System.out.println("This is a thingAction");

            }

        });

        // Java8之后

        jButton.addActionListener(e -> {

            System.out.println("This is a lambda thing!");

        });

```

> Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 [Comparator](http://javarevisited.blogspot.sg/2014/01/java-comparator-example-for-custom.html)。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 [Runnable](http://javarevisited.blogspot.sg/2012/01/difference-thread-vs-runnable-interface.html) 和 ActionListener 的过程中的套路来做。

### 三 使用lambda表达式对列表进行迭代



```

List numTemp = Arrays.asList("one", "two", "three", "four", "five");

// Java8之前

        for (Object temp : numTemp) {

            System.out.println(temp);

        }

        // Java8之后

        numTemp.forEach(n -> System.out.println(n));

        // Java8方法引用

        numTemp.forEach(System.out::println);

```

* 进阶

```

/**

 * 课程分类对象

 */

public class Category {

    /**

     * 课程id

     */

    private String categoryId;



    /**

     * 课程分类名称

     */

    private String categoryName;



    public Category() {

    }



    public Category(String categoryId, String categoryName) {

        this.categoryId = categoryId;

        this.categoryName = categoryName;

    }



    public String getCategoryId() {

        return categoryId;

    }



    public void setCategoryId(String categoryId) {

        this.categoryId = categoryId;

    }



    public String getCategoryName() {

        return categoryName;

    }



    public void setCategoryName(String categoryName) {

        this.categoryName = categoryName;

    }

```

```

 List numTemp = Arrays.asList("one", "two", "three", "four", "five");

        List<Category> categories = new ArrayList<>();

        categories.add(new Category("123", "123"));

        categories.add(new Category("12", "12"));

        categories.forEach(n -> n.setCategoryId("1"));

        categories.forEach(n -> System.out.println(n.getCategoryId() + n.getCategoryName()));



        // Java8之前

        for (Object temp : numTemp) {

            System.out.println(temp.toString());

        }

        // Java8之后

        numTemp.forEach(n -> System.out.println(n));

        // Java8方法引用

        numTemp.forEach(System.out::println);

```



### 四 使用lambda表达式和函数式接口Predicate



### 五 如何在lambda表达式中加入Predicate



### 六 Java 8中使用lambda表达式的Map和Reduce示例

```

 List<Integer> cost=Arrays.asList(100,200,300);

        // Java8之前

        for (Object costTemp : cost) {

            double price=Integer.parseInt(costTemp.toString())+.12*Integer.parseInt(costTemp.toString());

            System.out.println(price);

        }

        // Java8之后

        cost.stream().map((costTemp)->costTemp+.12*costTemp).forEach(System.out::println);

        Double bill=cost.stream().map((costTemp)->costTemp+.12*costTemp).reduce((sum,costTemp)->sum+costTemp).get();

        System.out.println(bill);

```

### 七 并行（parallel）数组

```

        long[] arrayOfLong = new long[20000];

        Arrays.parallelSetAll(arrayOfLong, index -> ThreadLocalRandom.current().nextInt(100000));

        Arrays.stream(arrayOfLong).limit(10).forEach(j -> System.out.print(j + " "));

        System.out.println();

        Arrays.parallelSort(arrayOfLong);

        Arrays.stream(arrayOfLong).limit(10).forEach(z -> System.out.print(z + " "));

```

