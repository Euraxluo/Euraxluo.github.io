---
layout:   post          
title:   05-13作业 
date:    2018-05-13       
author:   Euraxluo           
categories: java
tags: 
---
* TOC
{:toc}



#1.写一个捕捉异常的程序

+ 代码：



```java

import java.util.*;

public class homework513 {

    public static void main(String[] args) throws Exception {

        Scanner input = new Scanner(System.in);

        System.out.println("请输入一个除法运算");

        int beichushu = input.nextInt();

        int chushu = input.nextInt();

        try{

            if(chushu == 0)

            {

                throw new Exception("除数不能为0");

            }

            double ans = beichushu/chushu;

            System.out.println(beichushu+"/"+chushu+"="+ans);

        }catch (Exception e)

        {

            System.out.println(e);

        }

    }

}



```



#2请分别描述:final,finally,finalize?



+ 答：



+ final:



  如果一个类被声明为final，就意味着它不能再派生出新的子类，不能作为父类被继承。因此，一个类不能同时被声明为absrtact抽象类的和final的类。



  如果将变量或者方法声明为final，可以保证它们在使用中不被改变.被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明final的方法只能使用，不能重载。



+ finally是对Java 异常处理模型的最佳补充。finally 结构使代码总会执行，而不管有无异常发生。使用 finally 可以维护对象的内部状态，并可以清理非内存资源。



+ finalize：object中的方法名， Java技术使用finalize()方法在垃圾收集器将对象从内存中清除出去前，做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object类中定义的，因此所有的类都继承了它。



#3finally在IO操作中的作用，用程序说明



+ 代码



```java

import java.io.*;

import java.util.Scanner;

public class homework513{

    public static void main(String[] args) throws IOException {

        String File = "Test.txt";

        Scanner input = new Scanner(System.in);

        FileOutputStream fos = new FileOutputStream(File);

        try{

            /*进行io处理*/

            String str = "这是写入的字符";

            byte[] byte_str = str.getBytes();

            fos.write(byte_str);

            /*假设这有个异常*/

            if(true)

            {

                throw new Exception("这是一个错误");

            }

        }catch (Exception e){

            e.printStackTrace();

        }finally {

            /*这是一个统一关闭的地方*/

            fos.close();

        }

    }

}

```



#4自己封装一个异常，并且自行抛出，捕捉



+ 代码



```java

/*枚举类！enum_error.java*/

public enum enum_error {

    ERROR_1("0001","error1"),

    ERROR_2("0002","error2"),

    ERROR_3("0003","error3");

    private String errorcode;//错误代码

    private String message;//错误信息

    private enum_error(String errorcode, String message) {

        this.setErrorcode(errorcode);

        this.setMessage(message);

    }

    public String getErroecode() {

        return errorcode;

    }

    public void setErrorcode(String errorcode) {

        this.errorcode = errorcode;

    }

    public String getMessage() {

        return message;

    }

    public void setMessage(String message) {

        this.message = message;

    }

    /*重写toString*/

    public String toString(){

        return "[" + this.errorcode + "_" + this.message+"]";

    }

}

/*创建一个异常类MyRuntimeException继承RuntimeException*/

public class MyRuntimeException extends RuntimeException {

    public MyRuntimeException(Object Obj) {

        super(Obj.toString());

    }

}

/*测试类ExcetionTest*/

public class ExcetionTest {

    public static void main(String args[]) {

        Object user = null;

        try{

            if(user == null){

                throw new MyRuntimeException(enum_error.ERROR_1);

            }

        }catch (MyRuntimeException e){

            System.out.println(e);

        }

    }

}

```







#5将聊天服务端进行捕捉io异常



+ 代码



```java

import java.io.*;

import java.net.InetAddress;

import java.net.ServerSocket;

import java.net.Socket;

import java.util.*;



public class Server {

    private ServerSocket server;

    private Socket socket;



    public Server() {

        try {

            server = new ServerSocket(233);/*指定端口*/

        } catch (Exception e) {

            System.out.println("端口被占用");

        }

    }

    /*服务开启*/

    public void start(){

        try{

            System.out.println("等待客户端连接...");

            while(true){

                socket = server.accept();//监听端口

                System.out.println("一个客户端连接成功！");

                /*启动一个线程，负责与客户端通信*/

                GetClientMessage gcm = new GetClientMessage(socket);

                new Thread(gcm).start();

                new Thread(gcm).run();

            }

        }catch (Exception e){

            System.out.println("一个客户端连接失败！");

        }

    }



    public static void main(String[] args){

        Server server = new Server();

        server.start();



    }



    /*内部类*/

    private class GetClientMessage implements Runnable{

        private Socket socket;

        private String host;



        //通过socket得到远程计算机的信息

        public GetClientMessage(Socket socket){

            this.socket = socket;

            InetAddress address = socket.getInetAddress();

            host = address.getHostAddress();

        }



        public void run(){

            PrintWriter pw = null;

            try{

                /*建立两个信息流*/

                OutputStream output = socket.getOutputStream();

                InputStream input = socket.getInputStream();

                OutputStreamWriter osw = new OutputStreamWriter(output,"utf-8");

                InputStreamReader isr = new InputStreamReader(input,"utf-8");

                Scanner in= new Scanner(isr);

                PrintWriter out= new PrintWriter(osw,true);



                out.println("欢迎客户 "+host+" 连接！结束通话输入bye");

                /*客户端信息流*/

                String message = null;

                boolean flag=true;

                while(in.hasNextLine() && flag){

                    message = in.nextLine();

                    if(message.trim().endsWith("bye"))

                        flag=false;

                    System.out.println("["+host+"]说:"+message);

                }

                in.close();

                out.close();

            }catch (Exception e){

                System.out.println("服务器繁忙，请重试！");

            }finally {

                if(socket!=null){

                    try{

                        socket.close();

                    } catch (IOException e){

                        System.out.println("服务无法关闭！");

                    }

                }

            }

        }

    }

}

```
