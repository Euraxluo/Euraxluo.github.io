---
layout:   post          
title:   加密算法     
date:    2018-01-01    
author:   Euraxluo           
categories: java
tags:  加密
---
* TOC
{:toc}


# 加密算法。
BASE64编码算法不算是真正的加密算法。
MD5、SHA、HMAC这三种加密算法，非可逆加密，就是不可解密的加密方法，我们称之为单向加密算法。我们通常只把他们作为加密的基础。单纯的以上三种的加密并不可靠。 


#### BASE64 

按照RFC2045的定义，Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。（The Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.） 

常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。 

```

/**  

 * BASE64解密  

 *   

 * @param key  

 * @return  

 * @throws Exception  

 */    

public static byte[] decryptBASE64(String key) throws Exception {    

    return (new BASE64Decoder()).decodeBuffer(key);    

}    

    

/**  

 * BASE64加密  

 *   

 * @param key  

 * @return  

 * @throws Exception  

 */    

public static String encryptBASE64(byte[] key) throws Exception {    

    return (new BASE64Encoder()).encodeBuffer(key);    

}    

```

>主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。另，BASE加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。

#### MD5



MD5 -- message-digest algorithm 5 （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值。好比现在的ISO校验，都是MD5校验。怎么用？当然是把ISO经过MD5后产生MD5的值。一般下载linux-ISO的朋友都见过下载链接旁边放着MD5的串。就是用来验证文件是否一致的。

```

/**  

 * MD5加密  

 *   

 * @param data  

 * @return  

 * @throws Exception  

 */    

public static byte[] encryptMD5(byte[] data) throws Exception {    

    

    MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);    

    md5.update(data);    

    

    return md5.digest();    

    

}    

```

>通常我们不直接使用上述MD5加密。通常将MD5产生的字节数组交给BASE64再加密一把，得到相应的字符串。

#### SHA

SHA(Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了， 但是SHA仍然是公认的安全加密算法，较之MD5更为安全。 

```

 /**  

     * SHA加密  

     *   

     * @param data  

     * @return  

     * @throws Exception  

     */    

    public static byte[] encryptSHA(byte[] data) throws Exception {    

    

        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);    

        sha.update(data);    

    

        return sha.digest();    

    

    }    

}    

```

#### HMAC



HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。

```

/**  

 * 初始化HMAC密钥  

 *   

 * @return  

 * @throws Exception  

 */    

public static String initMacKey() throws Exception {    

    KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);    

    

    SecretKey secretKey = keyGenerator.generateKey();    

    return encryptBASE64(secretKey.getEncoded());    

}    

    

/**  

 * HMAC加密  

 *   

 * @param data  

 * @param key  

 * @return  

 * @throws Exception  

 */    

public static byte[] encryptHMAC(byte[] data, String key) throws Exception {    

    

    SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);    

    Mac mac = Mac.getInstance(secretKey.getAlgorithm());    

    mac.init(secretKey);    

    

    return mac.doFinal(data);    

    

}    

```





完整类

```

import java.security.MessageDigest;    

    

import javax.crypto.KeyGenerator;    

import javax.crypto.Mac;    

import javax.crypto.SecretKey;    

    

import sun.misc.BASE64Decoder;    

import sun.misc.BASE64Encoder;    

    

/**  

 * 基础加密组件  

 *   

 * @author 梁栋  

 * @version 1.0  

 * @since 1.0  

 */    

public abstract class Coder {    

    public static final String KEY_SHA = "SHA";    

    public static final String KEY_MD5 = "MD5";    

    

    /**  

     * MAC算法可选以下多种算法  

     *   

     * <pre>  

     * HmacMD5   

     * HmacSHA1   

     * HmacSHA256   

     * HmacSHA384   

     * HmacSHA512  

     * </pre>  

     */    

    public static final String KEY_MAC = "HmacMD5";    

    

    /**  

     * BASE64解密  

     *   

     * @param key  

     * @return  

     * @throws Exception  

     */    

    public static byte[] decryptBASE64(String key) throws Exception {    

        return (new BASE64Decoder()).decodeBuffer(key);    

    }    

    

    /**  

     * BASE64加密  

     *   

     * @param key  

     * @return  

     * @throws Exception  

     */    

    public static String encryptBASE64(byte[] key) throws Exception {    

        return (new BASE64Encoder()).encodeBuffer(key);    

    }    

    

    /**  

     * MD5加密  

     *   

     * @param data  

     * @return  

     * @throws Exception  

     */    

    public static byte[] encryptMD5(byte[] data) throws Exception {    

    

        MessageDigest md5 = MessageDigest.getInstance(KEY_MD5);    

        md5.update(data);    

    

        return md5.digest();    

    

    }    

    

    /**  

     * SHA加密  

     *   

     * @param data  

     * @return  

     * @throws Exception  

     */    

    public static byte[] encryptSHA(byte[] data) throws Exception {    

    

        MessageDigest sha = MessageDigest.getInstance(KEY_SHA);    

        sha.update(data);    

    

        return sha.digest();    

    

    }    

    

    /**  

     * 初始化HMAC密钥  

     *   

     * @return  

     * @throws Exception  

     */    

    public static String initMacKey() throws Exception {    

        KeyGenerator keyGenerator = KeyGenerator.getInstance(KEY_MAC);    

    

        SecretKey secretKey = keyGenerator.generateKey();    

        return encryptBASE64(secretKey.getEncoded());    

    }    

    

    /**  

     * HMAC加密  

     *   

     * @param data  

     * @param key  

     * @return  

     * @throws Exception  

     */    

    public static byte[] encryptHMAC(byte[] data, String key) throws Exception {    

    

        SecretKey secretKey = new SecretKeySpec(decryptBASE64(key), KEY_MAC);    

        Mac mac = Mac.getInstance(secretKey.getAlgorithm());    

        mac.init(secretKey);    

    

        return mac.doFinal(data);    

    

    }    

}    

```

测试类

```import static org.junit.Assert.*;    

    

import org.junit.Test;    

    

/**  

 *   

 * @author 梁栋  

 * @version 1.0  

 * @since 1.0  

 */    

public class CoderTest {    

    

    @Test    

    public void test() throws Exception {    

        String inputStr = "简单加密";    

        System.err.println("原文:/n" + inputStr);    

    

        byte[] inputData = inputStr.getBytes();    

        String code = Coder.encryptBASE64(inputData);    

    

        System.err.println("BASE64加密后:/n" + code);    

    

        byte[] output = Coder.decryptBASE64(code);    

    

        String outputStr = new String(output);    

    

        System.err.println("BASE64解密后:/n" + outputStr);    

    

        // 验证BASE64加密解密一致性    

        assertEquals(inputStr, outputStr);    

    

        // 验证MD5对于同一内容加密是否一致    

        assertArrayEquals(Coder.encryptMD5(inputData), Coder    

                .encryptMD5(inputData));    

    

        // 验证SHA对于同一内容加密是否一致    

        assertArrayEquals(Coder.encryptSHA(inputData), Coder    

                .encryptSHA(inputData));    

    

        String key = Coder.initMacKey();    

        System.err.println("Mac密钥:/n" + key);    

    

        // 验证HMAC对于同一内容，同一密钥加密是否一致    

        assertArrayEquals(Coder.encryptHMAC(inputData, key), Coder.encryptHMAC(    

                inputData, key));    

    

        BigInteger md5 = new BigInteger(Coder.encryptMD5(inputData));    

        System.err.println("MD5:/n" + md5.toString(16));    

    

        BigInteger sha = new BigInteger(Coder.encryptSHA(inputData));    

        System.err.println("SHA:/n" + sha.toString(32));    

    

        BigInteger mac = new BigInteger(Coder.encryptHMAC(inputData, inputStr));    

        System.err.println("HMAC:/n" + mac.toString(16));    

    }    

}    

```

