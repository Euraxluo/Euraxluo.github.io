---
layout:     post                    # 使用的布局（不需要改）
title:      数据结构和算法               # 标题 
subtitle:   算法面试                #副标题
date:       2019-03-20            # 时间
author:     Euraxluo                      # 作者
header-img: img/post-bg-github-cup.jpg  #这篇文章标题背景图片
catalog: true                 # 是否归档
tags:                               #标签
    - 数据结构和算法

---
## 如何准备算法面试 

### 从排序问题开始

- 有没有可能存在大量重复的元素
- 是否大部分数据距离它正确的位置很近
- 是否近乎有序
- 是否数据的取值范围很有限
- 是否需要稳定排序
- 是否使用链表存储
- 数据的大小是否可以装载在内存中

### 技术面的可能的问题

- 项目经历，项目中遇到的问题
- 遇到过那些bug，怎么解决
- 面向对象
- 设计模式
- 网络相关
- 设计模式
- 系统设计

### 关于思考行为方式的相关问题

- 遇到过的最大的挑战
- 翻过的错误
- 遭遇的失败
- 最享受的工作内容
- 遇到冲突的处理方式
- 做的最与众不同的事

### 关于合适的问题

- 小组的运行模式
- 项目的后续规划
- 产品中可能遇到的问题
- 为什么会选择某些技术，标准
- 我对某项技术很感兴趣，在入职的小组中有怎样的机会深入这种技术

### 算法面试中不会涉及高级数据结构和算法

- 红黑树
- B-Tree
- 斐波那契堆
- FFT
- 数论
- 计算几何
- 从暴力解法开始，逐步优化

### 时间复杂度

#### 常见的时间复杂度

二分：Ologn

查找数组中的最值On

归并排序：Onlogn，最差为n^2

选择排序：On^2

插入排序：On^2,最好为On

快速排序：Onlogn



#### 一个面试问题

有一个字符串数组，将字符串数组中的每一个字符串按照字母序排序之后，再将整个字符串按照字典序排序，求时间复杂度

最长的字符串长度为s；数组中有n个字符串

对每个字符串排序：Oslogs

将数组中的每一个字符串按照字母序排序：O(n*slogs)

将整个字符串数组按照字典序排序：O(s*nlogn)

答案：O(n*s*(logs+logn))

### 数据规模与时间复杂度

如果你想在1内解决问题:

最简单的指令：

O(n^2)的算法可以处理10^4级别的数据

O(n)的算法可以处理10^8级别的数据

O(nlogn)的算法可以处理10^7的数据

### 空间复杂度

数组：On

二维数组：On^2

常数：O1

递归：O(深度)

### 递归调用的复杂度分析（主定理）

#### 如果递归函数中，只进行一次递归调用

递归深度为depth

在每个递归函数中，时间复杂度为T

则总体时间复杂度为O(T*depth)

##### 例如：求幂操作

```c
double pow(double x,int n){
    assert(n >= );
    if(n == 0)
        return 1.0；
    double t = pow(x,n/2);
    if(n%2)
        return x*t*t;
    return t*t;
}
```

递归深度：n/2=1的次数：logn

每个递归的操作时间：2

总体时间复杂度：O(logn)

#### 递归中进行多次递归调用

多次递归需要通过计算递归树上的节点个数来计算

调用次数：m(数据规模)

树的深度：n

m^0+m^1+m^2+...+m^n = m^(n+1)-1

或者层数*每一层的数据规模

也就是O(m^n)

可以用二叉树剪枝=>动态规划

### 均摊复杂度

比如动态扩容数组，在没有进行扩容的节点，插入操作时O1，当发生扩容时，需要把原来数组中的数据拷贝到新扩容的数组中，这时插入操作的时间复杂度时On，但是采取分摊的思想，我们每个元素操作时进行2次操作，时间复杂度还是O1

当我们使用收缩时，请将收缩条件设置比收缩后的容量更小，否则，收缩操作将会频繁

比如：

```c++
#include <iostream>
#include <string.h>
#include <assert.h>
using namespace std;
template <typename T>
class MyVector{
private:
    T* data;
    int capacity;//存储数组中可以容纳的最大的元素个数
    int size;//存储数组中的元素个数
    void resize(int newCapacity){
        assert( newCapacity >= size );
        T *newData = new T[newCapacity];
        for (int i = 0;i<size;i++)
            newData[i] = data[i];
        delete[] data;
        data = newData;
        capacity = newCapacity;
    }
public:
    MyVector(){
        data = new T(10);//初始分配10个空间
        capacity = 10;
        size = 0;
    }
    ~MyVector(){//析构函数
        delete[] data;
    }
    void push_back(T e){
        assert( size < capacity );
        if(size == capacity)
            resize(2*capacity);
        data[size++] = e;
    }
    T pop_back(){
        assert( size > 0 );
        T ret = data[size-1];
        size --;
        if(size == capacity/4)//防止复杂度震荡，如果删除和添加都在11处，且这里判定条件是capacity/2
            resize(capacity/2);
        return ret;
    }
};
```

