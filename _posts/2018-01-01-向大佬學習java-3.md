---
layout:   post          
title:   wss&nginx支持
date:    2018-01-01    
author:   Euraxluo           
categories: java
tags:  客户端 连接
---
* TOC
{:toc}


# wss介绍
现在，很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

在这种情况下，HTML5定义了WebSocket协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。



WebSocket一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

简单点说，WebSocket 就是减小客户端与服务器端建立连接的次数，减小系统资源开销，只需要一次 HTTP 握手，整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直与客户端保持连接，直到你关闭请求，同时由原本的客户端主动询问，转换为服务器有信息的时候推送。当然，它还能做实时通信、更好的二进制支持、支持扩展、更好的压缩效果等这些优点。

>ws 和 wss 又是什么鬼？

Websocket使用 ws 或 wss 的统一资源标志符，类似于 HTTP 或 HTTPS ，其中 wss 表示在 TLS 之上的 Websocket ，相当于 HTTPS 了。如：



`ws://example.com/chat`

`wss://example.com/chat`

默认情况下，Websocket 的 ws 协议使用 80 端口；运行在TLS之上时，wss 协议默认使用 443 端口。其实说白了，wss 就是 ws 基于 SSL 的安全传输，与 HTTPS 一样样的道理。



如果你的网站是 HTTPS 协议的，那你就不能使用 ws:// 了，浏览器会 block 掉连接，和 HTTPS 下不允许 HTTP 请求一样，如下图：

![image.png](https://upload-images.jianshu.io/upload_images/10020820-82f1617e24b1ad02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

>Mixed Content: The page at 'https://domain.com/' was loaded over HTTPS, but attempted to connect to the insecure WebSocket endpoint 'ws://x.x.x.x:xxxx/'. This request has been blocked; this endpoint must be available over WSS.



这种情况，毫无疑问我们就需要使用 wss:\ 安全协议了，我们是不是简单的把 ws:\ 改为 wss:\ 就行了？那试试呗。



改好了，报错啦！！！

![image.png](https://upload-images.jianshu.io/upload_images/10020820-a45317067fe0087f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)



>VM512:35 WebSocket connection to 'wss://IP地址:端口号/websocket' failed: Error in connection establishment: net::ERR_SSL_PROTOCOL_ERROR



很明显 SSL 协议错误，说明就是证书问题了。记着，这时候我们一直拿的是 IP地址 + 端口号 这种方式连接 WebSocket 的，这根本就没有证书存在好么，况且生成环境你也要用 IP地址 + 端口号 这种方式连接 WebSocket 吗？肯定不行阿，要用域名方式连接 WebSocket 阿。

>Nginx 配置域名支持 WSS

```

location /websocket {

    proxy_pass http://backend;

    proxy_http_version 1.1;

    proxy_set_header Upgrade $http_upgrade;

    proxy_set_header Connection "upgrade";}

```

接着拿域名再次连接试一下，不出意外会看 101 状态码：

这样就完成了，在 HTTPPS 下以域名方式连接 WebSocket ，可以开心的玩耍了。



稍微解释一下 Nginx 配置



Nginx 自从 1.3 版本就开始支持 WebSocket 了，并且可以为 WebSocket 应用程序做反向代理和负载均衡。



WebSocket 和 HTTP 协议不同，但是 WebSocket 中的握手和 HTTP 中的握手兼容，它使用 HTTP 中的 Upgrade 协议头将连接从 HTTP 升级到 WebSocket，当客户端发过来一个 Connection: Upgrade 请求头时，Nginx 是不知道的，所以，当 Nginx 代理服务器拦截到一个客户端发来的 Upgrade 请求时，需要显式来设置 Connection 、 Upgrade 头信息，并使用 101（交换协议）返回响应，在客户端和代理服务器、后端服务器之间建立隧道来支持 WebSocket。



当然，还需要注意一下，WebSockets 仍然受到 Nginx 缺省为60秒的 proxy_read_timeout 的影响。这意味着，如果你有一个程序使用了 WebSockets，但又可能超过60秒不发送任何数据的话，那你要么需要增加超时时间，要么实现一个 ping 的消息以保持联系。使用 ping 的解决方法有额外的好处，可以发现连接是否被意外关闭。



# nginx配置wss



如下配置nginx



```

map $http_upgrade $connection_upgrade {  

    default upgrade;  

    '' close;  

}  

upstream websocket {  

    server 128.190.82.105:8888;  

}  

server {  

    listen 8888;  

    server_name proxy.hello.com;

    ssl on;

    ssl_certificate /etc/nginx/ssl/hello.com_bundle.crt;

    ssl_certificate_key /etc/nginx/ssl/hello.com.key;

    ssl_session_timeout 20m;

    ssl_verify_client off;

    location / {  

        proxy_pass http://websocket;  

        proxy_http_version 1.1;  

        proxy_set_header Upgrade $http_upgrade;  

        proxy_set_header Connection "Upgrade";  

    }  

}



```



128.190.82.105:8888是真正的服务端地址，nginx所在域名是proxy.hello.com，代理的端口号是8888，所以前端访问的时候这样配置：



```

WEBSOCKET_URL: 'wss://proxy.hello.com:8888',  



```



![image.png](https://upload-images.jianshu.io/upload_images/10020820-de9b69cad74b65d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)





检查nginx.conf正确性：



```

nginx -t



```



重新加载配置文件：



```

nginx -s reload

```





