---
layout:   post          
title:   05-07作业 
date:    2018-05-07       
author:   Euraxluo           
categories: java
tags:  虚拟机 字符串 方法
---
* TOC
{:toc}



#1.何为JDK API?

+ 答：API是应用程序编程接口，是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件的以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。





#2.JDK API 应用场景?

+ 答：运行Java程序时，虚拟机装载程序的class文件所使用的Java API class文件。



   





#3.JDK API 中的文档注释?

+ 答：文档注释可以用于注释类、属性、方法等说明，而且通过JDK工具jdk/bin/javadoc.exe指令直接生成相关文档， 





#4.JDK API 中String API对象?



##1)String 类应用场景?

+ 答：String 类代表字符串。Java 程序中的所有字符串字面值都作为此类的实例实现,可以做application



##2)String类的应用特点?

+ 答：String的设计是一个典型的单一模式

  `String str1=new String("AAAA")；`

  `String str2=new String("AAAA")；`

  此类使用final修饰,不允许被继承



##3)String类型的字符串有什么特点?

+ 答：

  底层使用char[]数组存储，编码为unicode

  String是对象,而且一次创建终身不变的对象

  有个String常量池





##4)String类型常用API方法

+ 答：



  | 方法                                          | 说明                                        |

  | --------------------------------------------- | ------------------------------------------- |

  | int length()                                  | 返回当前字符串的长度                        |

  | int indexOf(int ch)                           | 查找ch字符在该字符串中第一次出现的位置      |

  | int lastIndexOf(int ch)                       | 查找ch字符在该字符串中最后一次出现的位置    |

  | String substring(int beginIndex,int endIndex) | 获取从beginIndex到endIndex位置的字符串      |

  | boolean equals(Object obj)                    | 将该字符串与指定对象比较，返回true或者false |

  | String trim()                                 | 返回去除了前后空格的字符串                  |

  | String toLowerCase()                          | 将字符串转换为小写                          |

  | String toUpperCase()                          | 将字符串转换为大写                          |

  | char charAt(int index)                        | 获取字符串指定位置的字符                    |

  | String[] split (String regex,int limit)       | 将字符串分割为子字符串，返回字符串数组      |

  | byte[] getBytes()                             | 将字符串转换为byte数组                      |



----------------------------------------------------------------

#FAQ?

##1.JVM内存的基本结构?(堆,栈,方法区)

+ 答：

>1.方法区(永久代)：与java堆一样，是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

>

>2.堆:FIFO,Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，在实现时，既可以实现成固定大小的，也可以是可扩展的，如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常

>

>3.栈:FILO,每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

>

>4.存储的数据类型

>堆用来存储new出来的对象和数组

>栈用来存储基本类型变量和对象的引用变量的地址

>方法区存储方法和static变量



##2.JVM中的堆,栈,方法区何时创建?(JVM运行时创建)

+ 答：

>栈：JAVA虚拟机进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方 法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。

>

>堆：当JAVA虚拟机 执行方法时，JAVA虚拟机根据局部变量持有的引用，定位到堆区中的实例，再根据实例持有的引用，定位到方法中类的类型信息，从而获得方法的字节码，接着执行方法包含的指令。

>

>方法区：一直存在

>



##3.JVM堆内存可能有溢出吗?(有,先了解)

+ 答：

 >栈溢出：抛出StackOverflowError错误，出现此种情况是因为方法运行的时候栈的深度超过了虚拟机容许的最大深度所致。

 >>

 >>如果线程请求的栈容量超过栈允许的最大容量的话，Java 虚拟机将抛出一个StackOverflow异常；如果Java虚拟机栈可以动态扩展，并且扩展的动作已经尝试过，但是无法申请到足够的内存去完成扩展，或者在新建立线程的时候没有足够的内存去创建对应的虚拟机栈，那么Java虚拟机将抛出一个OutOfMemory 异常。

 >>堆内存溢出：虚拟机会抛出java.lang.OutOfMemoryError:java heap space,出现此种问题的时候有可能是内存泄露，也有可能是内存溢出了。

 >>

 >>方法区溢出：Class对象未被释放，Class对象占用信息过多，有过多的Class对象





##4.String中用到的常量池在JVM的哪块内存中?(JDK7 堆)

+ 答：

>jdk1.8，常量池在heap区？



##5.定义一个方法验证某个字符串是否是回文.

+ 答：abcdcba是回文

+ 代码：

```java

package homework;

public class homework507 {

	public static void main(String [] args) {

		String str = "abcdcba";

		if(huiwen(str)) {

			System.out.println(str+"是回文");

		}else {

			System.out.println(str+"不是回文");

		}

	}

	private static boolean huiwen(String str) {

		// TODO 自动生成的方法存根

		for(int i=0;i<str.length()/2;i++) {

			if(str.charAt(i)==str.charAt(str.length()-i-1))

				return true;

		}

		return false;

	}

}



```
