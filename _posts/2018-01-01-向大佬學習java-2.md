---
layout:   post          
title:   websocket 
date:    2018-01-01    
author:   Euraxluo           
categories: java
tags:  连接
---
* TOC
{:toc}


## 简单说明

1.两种方式，一种使用tomcat的websocket实现，一种使用spring的websocket


2.tomcat的方式需要tomcat 7.x，JEE7的支持。



3.spring与websocket整合需要spring 4.x，并且使用了socketjs，对不支持websocket的浏览器可以模拟websocket使用



## 方式一：tomcat



使用这种方式无需别的任何配置，只需服务端一个处理类，



### 服务器端代码

```

@ServerEndpoint(value = "/websocket")

@Component

public class MyWebSocket {

    /**

     * 获取当前websocket数量

     */

    private static int onlineCount = 0;



    /**

     * 线程安全websocket

     */

    private static CopyOnWriteArraySet<MyWebSocket> webSocketSet = new CopyOnWriteArraySet<MyWebSocket>();





    public static CopyOnWriteArraySet<MyWebSocket> getWebSocketSet() {

        return webSocketSet;

    }



    /**

     * websocket的session

     */

    private Session session;



    /**

     * 统一返回结果

     */

    private String result;



    /**

     * 订单号

     */

    private String outTradeNo;



    public String getOutTradeNo() {

        return outTradeNo;

    }



    /**

     * 打开websoekt

     */

    @OnOpen

    public void onOpen(Session session) {

        this.session = session;

        //添加websoket

        webSocketSet.add(this);

        //数量加1

        addOnlineCount();



        System.out.println("当前连接sessionId: " + session.getId() + "  当前总连接数:" + getOnlineCount());

        try {

            sendMessage(JSON.toJSONString(new ReturnJson(NumEnum.SUCCESS.getIndex(), "你的websocket连接成功!")));

        } catch (Exception e) {

//            log.error("sessionId: " + session.getId() + " -- onOpen -- Method -- error!", e);

        }

    }



    /**

     * 关闭websocket

     */

    @OnClose

    public void onClose() {

        //去除websoekt

        webSocketSet.remove(this);

        //数量减1

        subOnlineCount();

        System.out.println("有websoket关闭，当前数量：" + getOnlineCount());

    }



    /**

     * 传递消息

     *

     * @param message 先关信息

     */

    @OnMessage 

    public void onMessage(String message, Session session) throws Exception {

        System.out.println();

        System.out.println("sesionId为 " + session.getId() + "来消息：" + message);

        // 获取前端发送来的消息

        JSONObject jsonObjectFast = JSON.parseObject(message);

        // 辨别前端调用接口

        String interfaceTemp = jsonObjectFast.getString("interface");

        try {

            switch (interfaceTemp) {

                // 获取轮播图

                case "lisenPayBack":

                    String outTradeNoTemp = jsonObjectFast.getString("outTradeNo");

                    this.outTradeNo = outTradeNoTemp;

                    result = JSON.toJSONString(new ReturnJson(NumEnum.SUCCESS.getIndex(), "监听成功!"));

                    break;

            }

            pushMessageToClient(session.getId(), result);

        } catch (NullPointerException n) {

            result = JSON.toJSONString(new ReturnJson(NumEnum.FAIL.getIndex(), "缺少必要参数！"));

        }

    }



    /**

     * Description: 发送消息给前端

     *

     * @param

     * @return void

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:31

     */

    public void pushMessageToClient(String sessionId, String message) {

        for (MyWebSocket item : webSocketSet) {

            try {

                if (item.session.getId().equals(sessionId)) {

                    item.sendMessage(message);

                }

            } catch (IOException e) {

//                log.error("发送消息出错！", e);

            }

        }

    }



    /**

     * Description: 出错记录

     *

     * @param

     * @return void

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:31

     */

    @OnError

    public void onError(Session session, Throwable error) {

//        log.error("sessionId: " + session.getId() + " websocket出错!" + error.getMessage());

    }



    /**

     * Description: 发送消息

     *

     * @param

     * @return void

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:32

     */

    public void sendMessage(String message) throws IOException {

        this.session.getBasicRemote().sendText(message);

    }



    /**

     * Description: 记录当前wensocket数量

     *

     * @param

     * @return int

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:32

     */

    public static synchronized int getOnlineCount() {

        return onlineCount;

    }



    /**

     * Description: websoket数量减一

     *

     * @param

     * @return void

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:32

     */

    public static synchronized void addOnlineCount() {

        MyWebSocket.onlineCount++;

    }



    /**

     * Description: websocket数量加一

     *

     * @param

     * @return void

     * @Author: Bruse Queen

     * @Date: 2018/3/29-16:33

     */

    public static synchronized void subOnlineCount() {

        MyWebSocket.onlineCount--;

    }



}

```



客户端js

```

<!DOCTYPE HTML>

<html>

<head>

    <title>My WebSocket</title>

</head>



<body>

Welcome<br/>



<textarea id="text" type="text" style="width: 500px;height: 200px;"></textarea>



<button onclick="send()">Send</button>    <button onclick="closeWebSocket()">Close</button>

<div id="message">

</div>

</body>



<script type="text/javascript">

    var websocket = null;



    //判断当前浏览器是否支持WebSocket

    if('WebSocket' in window){

        // websocket = new WebSocket("ws://10.20.5.200:8090/itfer-zzdy/websocket");

        // websocket = new WebSocket("ws://10.20.5.200:8088/websocket");

        websocket = new WebSocket("ws://localhost:8080/testmybatis/websocket");

    }

    else{

        alert('Not support websocket')

    }



    //连接发生错误的回调方法

    websocket.onerror = function(){

        setMessageInnerHTML("error");

    };



    //连接成功建立的回调方法

    websocket.onopen = function(event){

        setMessageInnerHTML("open");

    }



    //接收到消息的回调方法

    websocket.onmessage = function(event){

        setMessageInnerHTML(event.data);

    }



    //连接关闭的回调方法

    websocket.onclose = function(){

        setMessageInnerHTML("close");

    }



    //监听窗口关闭事件，当窗口关闭时，主动去关闭websocket连接，防止连接还没断开就关闭窗口，server端会抛异常。

    window.onbeforeunload = function(){

        websocket.close();

    }



    //将消息显示在网页上

    function setMessageInnerHTML(innerHTML){

        document.getElementById('message').innerHTML += innerHTML + '<br/>';

    }



    //关闭连接

    function closeWebSocket(){

        websocket.close();

    }



    //发送消息

    function send(){

        var message = document.getElementById('text').value;

        websocket.send(message);

    }

</script>

</html>

```

发送消息只需要使用websocket.send("发送消息")，就可以触发服务端的onMessage()方法，当连接时，触发服务器端onOpen()方法，此时也可以调用发送消息的方法去发送消息。关闭websocket时，触发服务器端onclose()方法，此时也可以发送消息，但是不能发送给自己，因为自己的已经关闭了连接，但是可以发送给其他人。



方法二：spring整合



此方式基于spring mvc框架，相关配置可以看我的相关博客文章





WebSocketConfig.java



这个类是配置类，所以需要在spring mvc配置文件中加入对这个类的扫描，第一个addHandler是对正常连接的配置，第二个是如果浏览器不支持websocket，使用socketjs模拟websocket的连接。

```

package com.websocket;  

  

import org.springframework.context.annotation.Bean;  

import org.springframework.context.annotation.Configuration;  

import org.springframework.web.socket.config.annotation.EnableWebSocket;  

import org.springframework.web.socket.config.annotation.WebSocketConfigurer;  

import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;  

import org.springframework.web.socket.handler.TextWebSocketHandler;  

  

@Configuration  

@EnableWebSocket  

public class WebSocketConfig implements WebSocketConfigurer {  

    @Override  

    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {  

        registry.addHandler(chatMessageHandler(),"/webSocketServer").addInterceptors(new ChatHandshakeInterceptor());  

        registry.addHandler(chatMessageHandler(), "/sockjs/webSocketServer").addInterceptors(new ChatHandshakeInterceptor()).withSockJS();  

    }  

   

    @Bean  

    public TextWebSocketHandler chatMessageHandler(){  

        return new ChatMessageHandler();  

    }  

  

}  

```

ChatMessageHandler.java



这个类是对消息的一些处理，比如是发给一个人，还是发给所有人，并且前端连接时触发的一些动作

```

package com.websocket;  

  

import java.io.IOException;  

import java.util.ArrayList;  

import org.apache.log4j.Logger;  

import org.springframework.web.socket.CloseStatus;  

import org.springframework.web.socket.TextMessage;  

import org.springframework.web.socket.WebSocketSession;  

import org.springframework.web.socket.handler.TextWebSocketHandler;  

  

public class ChatMessageHandler extends TextWebSocketHandler {  

  

    private static final ArrayList<WebSocketSession> users;// 这个会出现性能问题，最好用Map来存储，key用userid  

    private static Logger logger = Logger.getLogger(ChatMessageHandler.class);  

  

    static {  

        users = new ArrayList<WebSocketSession>();  

    }  

  

    /** 

     * 连接成功时候，会触发UI上onopen方法 

     */  

    @Override  

    public void afterConnectionEstablished(WebSocketSession session) throws Exception {  

        System.out.println("connect to the websocket success......");  

        users.add(session);  

        // 这块会实现自己业务，比如，当用户登录后，会把离线消息推送给用户  

        // TextMessage returnMessage = new TextMessage("你将收到的离线");  

        // session.sendMessage(returnMessage);  

    }  

  

    /** 

     * 在UI在用js调用websocket.send()时候，会调用该方法 

     */  

    @Override  

    protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {  

        sendMessageToUsers(message);  

        //super.handleTextMessage(session, message);  

    }  

  

    /** 

     * 给某个用户发送消息 

     * 

     * @param userName 

     * @param message 

     */  

    public void sendMessageToUser(String userName, TextMessage message) {  

        for (WebSocketSession user : users) {  

            if (user.getAttributes().get(Constants.WEBSOCKET_USERNAME).equals(userName)) {  

                try {  

                    if (user.isOpen()) {  

                        user.sendMessage(message);  

                    }  

                } catch (IOException e) {  

                    e.printStackTrace();  

                }  

                break;  

            }  

        }  

    }  

  

    /** 

     * 给所有在线用户发送消息 

     * 

     * @param message 

     */  

    public void sendMessageToUsers(TextMessage message) {  

        for (WebSocketSession user : users) {  

            try {  

                if (user.isOpen()) {  

                    user.sendMessage(message);  

                }  

            } catch (IOException e) {  

                e.printStackTrace();  

            }  

        }  

    }  

  

    @Override  

    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {  

        if (session.isOpen()) {  

            session.close();  

        }  

        logger.debug("websocket connection closed......");  

        users.remove(session);  

    }  

  

    @Override  

    public void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception {  

        logger.debug("websocket connection closed......");  

        users.remove(session);  

    }  

  

    @Override  

    public boolean supportsPartialMessages() {  

        return false;  

    }  

  

}  

```



spring-mvc.xml



正常的配置文件，同时需要增加对WebSocketConfig.java类的扫描，并且增加

```

xmlns:websocket="http://www.springframework.org/schema/websocket"  

              http://www.springframework.org/schema/websocket   

              <a target="_blank" href="http://www.springframework.org/schema/websocket/spring-websocket-4.1.xsd">http://www.springframework.org/schema/websocket/spring-websocket-4.1.xsd</a>  

```



客户端



```

<script type="text/javascript"  

        src="http://localhost:8080/Bank/js/sockjs-0.3.min.js"></script>  

    <script>  

        var websocket;  

      

        if ('WebSocket' in window) {  

            websocket = new WebSocket("ws://" + document.location.host + "/Bank/webSocketServer");  

        } else if ('MozWebSocket' in window) {  

            websocket = new MozWebSocket("ws://" + document.location.host + "/Bank/webSocketServer");  

        } else {  

            websocket = new SockJS("http://" + document.location.host + "/Bank/sockjs/webSocketServer");  

        }  

      

        websocket.onopen = function(evnt) {};  

        websocket.onmessage = function(evnt) {  

            $("#test").html("(<font color='red'>" + evnt.data + "</font>)")  

        };  

      

        websocket.onerror = function(evnt) {};  

        websocket.onclose = function(evnt) {}  

      

        $('#btn').on('click', function() {  

            if (websocket.readyState == websocket.OPEN) {  

                var msg = $('#id').val();  

                //调用后台handleTextMessage方法  

                websocket.send(msg);  

            } else {  

                alert("连接失败!");  

            }  

        });  

    </script>  

```

