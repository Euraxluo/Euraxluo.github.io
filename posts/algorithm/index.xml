<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Euraxluo Blog</title><link>/posts/algorithm/</link><description>Recent content in algorithm on Euraxluo Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>Copyright © 2016-{year} Euraxluo. All Rights Reserved.</copyright><lastBuildDate>Sat, 20 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="/posts/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>数组</title><link>/posts/algorithm/%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate><guid>/posts/algorithm/%E6%95%B0%E7%BB%84/</guid><description>线性表(每个线性表上的数据最多只有前和后两个方向):数组,链表,队列,栈 非线性表(数据之间并不是简单的前后关系):二叉树,堆,图
数组的概念 数组( Array )是一种线性表数据结构。它用一组连续的内存空间,来存储一组具有相同类型的数据。
数组的特点 连续的内存空间和相同类型的数据
数组的优点 随机访问:利用寻址公式对元素进行访问:
a[i]_address = base_address + i * data_type_size
数组的查找操作时间复杂度不是O(1),即便是排好的数组,用二分查找,时间复杂度也是O(logn);正确的说法
数组支持随机访问,根据下标随机访问的时间复杂度为O(1)
数组的缺点 低效的插入和删除
插入:最好O(1),最坏O(n) 数组若无序,插入新的元素时,可以将第 K 个位置元素移动到数组末尾,把新的元素,插入到第 k 个位置,此处复杂度为O(1)
删除:最好O(1),最坏O(n) 多次删除集中在一起,提高删除效率,记录下已经被删除的数据,每次的删除操作并不是搬移数据,只是记录数据已经被删除,当数组没有更多的存储空间时,再触发一次真正的删除操作。即 JVM 标记清除垃圾回收算法。
标记 - 清除算法
标记 - 清除算法在垃圾收集时会先标记出需要回收的对象,标记完成后统一回收所有被标记的对象。清除之后会产生大量不连续的内存碎片。标记 - 整理垃圾回收算法在标记完成之后让所有存活的对象都向一端移动,然后直接清理掉边界以外的内存
访问越界
数组越界在 C 语言中是一种未决行为,并没有规定数组访问越界时编译器应该如何处理。因为,访问数组的本质就是访问一段连续内存,只要数组通过偏移计算得到的内存地址是可用的,那么程序就可能不会报任何错误
数组和容器 容器能否完全替代数组(ArrayList,vector)
相比于数组, java 中的 ArrayList 封装了数组的很多细节(插入删除时数据的迁移工作),并支持动态扩容。一旦超过存储容量,扩容时比较耗时,因为涉及到内存申请和数据搬移。
Java ArrayList 无法存储基本类型,比如 int 、 long ,需要封装为 Integer 、 Long 类,而Autoboxing 、 Unboxing 则有一定的性能消耗,所以如果特别关注性能,或者希望使用基本类型,就可以选用数组。
如果数据大小事先已知,并且对数据的操作非常简单,用不到 ArrayList 提供的大部分方法,也可以直接使用数组。
当要表示多维数组时,用数组往往会更加直观。比如 Object[][]array ;而用容器的话则需要这样定义: ArrayList&amp;lt;ArrayList &amp;gt; array 。</description></item><item><title>链表</title><link>/posts/algorithm/%E9%93%BE%E8%A1%A8/</link><pubDate>Sat, 20 Oct 2018 00:00:00 +0000</pubDate><guid>/posts/algorithm/%E9%93%BE%E8%A1%A8/</guid><description>单链表 data.next--&amp;gt;data.next--&amp;gt;NULL
时间复杂度 插入节点:
时间复杂度:O1
删除节点
时间复杂度:O1
查找节点
时间复杂度:O(n)
链表想要随机访问第K个元素arr[k],需要根据指针一个一个找
双向链表 --&amp;gt;prev.data.next&amp;lt;==&amp;gt;prev.data.next&amp;lt;==&amp;gt;prev.data.next 即支持两个方向,每个节点不知有一个后继指针next,还有一个前驱指针prev指向前面的结点
空间复杂度 双向链表需要额外的两个空间来存储后继结点和其前驱结点的地址.所以,如果存储同样多的数据,双向链表要比单链表占用更多的内存空间.虽然两个指针比较浪费存储空间,但是可以支持双向遍历.这样也带来了双向链表操作的灵活性
特点 双向链表可以支持O1时间复杂度的情况下找到前驱结点,这样,双向链表在某些情况的插入,删除操作都要比单链表简单高校.
循环链表 单链表的尾节点指针指向空地址
循环链表的尾节点指针指向链表的头结点
优点:从链尾到链头比较方便.当要处理的数据具有环型结构特点时,就特别适合采用循环链表 把约瑟夫问题降低到O(n)时间复杂度
具体的复杂度分析: 删除操作,有两种情况 删除结点中 “ 值等于某个给定值 ” 的结点; 删除给定指针指向的结点。 第一种情况,为了找到节点的值等于给定值的结点,单链表和双向链表都要从头结点一个一个一次遍历比较,直到找到这个节点,才利用指正操作进行删除.
主要的时间复杂度在于遍历结点,时间复杂度为On
第二种情况,我们知道要删除哪一个结点,可是删除这个结点的操作需要其前驱结点的参与,因此我们还要知道指向前驱结点的指正.这时双向链表和单链表的区别就体现出来了.
单链表依然需要从头结点开始遍历链表.因此,单链表删除的时间复杂度为On
双向链表的结点中有prev,可以直接删除,因此,双向链表删除的时间复杂度为O1
查找 除了插入和删除操作以外,双向链表的按值查询效率也比单链表快
记录上次查找的位置P,每次查询时,根据要查找的值与P的大小关系,决定是往前还是往后查找,平均下来只需要查找一般的数据
范例 LinkedHashMap,采用了双向链表的数据结构
链表与数组 数组 实现上使用的是连续的内存空间,可以借助CPU的缓存机制,预读数组中的数据,所以访问效率高
缺点:大小固定,如果内存不够,只能重新再申请一个更大的内存空间,把原数组拷贝进去,费时
链表 在内存中并不是连续存储,对于CPU缓存不友好,没有办法有效预读.
与数组相比,天然支持动态扩容
缺点:需要消耗额外的存储空间去存储一份指向下一个结点的指正,所以内存消耗会翻倍.并且,对链表进行频繁的插入,删除操作,还会导致频繁的内存申请和释放,容易造成内存碎片.比如java:会导致频繁的GC(垃圾回收)
基于链表实现LRU缓存淘汰法 思路:
我们维护一个有序单链表,越靠近链表尾部的结点是越早之前访问的,当有一个新的数据被访问时,我们从链表头开始顺序遍历链表.
如果此数据之前已经被缓存在链表中了,我们遍历得到这个数据对应的结点,并将其从原来的位置删除,然后插入到链表的头部
如果这数据没有在缓存链表中,又可以分为两种情况:
如果此时缓存未满,则将此节点直接插入到链表的头部
如果此时缓存已满,则链表尾结点删除,将新的数据结点插入到链表的头部
时间复杂度:O(n)
优化:引入散列表,来记录每个数据的位置,将缓存访问的时间复杂度降到O1
代码: 查找key:
//在数组中a中,查找key,返回key所在的位置 int find(char* a, int n, char key) { //边界条件处理,如果 a 为空,或者n&amp;lt;=0,说明数组中没有数据,就不用while循环比较了 if(a == null || n &amp;lt;= 0) { return -1; } int i = 0; //这里有两个比较操作: i&amp;lt;n 和 a[i]==key.</description></item></channel></rss>